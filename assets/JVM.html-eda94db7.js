import{_ as a,Y as e,Z as o,a2 as r,a1 as l,E as t}from"./framework-5e11dbd9.js";const s={},d=l('<h2 id="介绍下-jvm-内存模型-分为哪些区域-各区域的作用是什么" tabindex="-1"><a class="header-anchor" href="#介绍下-jvm-内存模型-分为哪些区域-各区域的作用是什么" aria-hidden="true">#</a> 介绍下 JVM 内存模型，分为哪些区域？各区域的作用是什么？</h2><ul><li><p>程序计数器：是线程私有的，存放当前线程执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一个要执行的字节码指令</p></li><li><p>虚拟机栈：是线程私有的，存放方法的调用栈，每一次方法的调用都会创建一个栈帧并把它被压入栈，栈帧中包含局部变量表、操作数栈、动态链接和方法出口等</p></li><li><p>本地方法栈：是线程私有的，存放本地方法的调用栈</p><blockquote><p>本地方法一般使用C、C++语言编写的，与底层操作系统交互，Java通过本地方法间接地访问底层操作系统的资源。本地方法由 <code>native</code> 修饰</p></blockquote></li><li><p>堆：是所有线程共享的，存放对象实例，也是垃圾回收的主要区域</p></li><li><p>方法区：是所有线程共享的，存放每个类的结构信息，如运行时常量池、字段和方法数据，以及成员方法和构造函数（包括用于类、实例对象初始化、接口实例化的特殊方法）的代码</p></li></ul><h2 id="什么是双亲委派模式-有什么作用" tabindex="-1"><a class="header-anchor" href="#什么是双亲委派模式-有什么作用" aria-hidden="true">#</a> 什么是双亲委派模式？有什么作用？</h2><p>在 Java 中，类加载器负责将字节码加载到内存，并生成对应的 <code>Class</code> 对象，双亲委派模式就是类加载器的一种工作方式。当一个类加载器要加载一个类时，会先委派给它的父类加载器进行加载，如果父类加载器无法加载，才由自己加载。具体流程如下：</p><ol><li>先判断该类是否已经被加载过，如果被加载过就直接返回对应的 <code>Class</code> 对象</li><li>如果该类没被加载过，则委托给父类加载器去加载（重复 1-2 步骤），直到交由顶层的启动类加载器加载</li><li>如果父类加载器无法加载，才会自己去加载</li></ol>',5),p=l('<p>双亲委派模式的好处：</p><ul><li>避免类的重复加载：当进行类加载时，会先查找该类是否已经加载过了，避免重复加载</li><li>保证核心库的安全：Java 核心库是由启动类加载器加载的，通过双亲委派模式可以保障 Java 核心库的安全性，避免程序对 Java 核心库的篡改</li><li>自定义类加载器：基于双亲委派模式编写自己的类加载器，根据不同的需求对类的加载过程进行定制化</li></ul><h2 id="讲一下jvm-类加载的执行过程" tabindex="-1"><a class="header-anchor" href="#讲一下jvm-类加载的执行过程" aria-hidden="true">#</a> 讲一下JVM 类加载的执行过程</h2><ol><li>加载：根据类的全名，获取 class 文件二进制字节流</li><li>连接-验证：class 文件的格式验证，如魔数等</li><li>加载：将 class 文件加载到方法区并转换为运行时数据结构</li><li>加载：在堆内存中生成这个类的对象，作为 class 文件的访问入口</li><li>连接-验证：元数据验证、字节码验证</li><li>连接-准备：为类变量分配内存并设置初始值 <ul><li>static 变量，分配空间在准备阶段完成（设置默认值），赋值在初始化阶段完成</li><li>static 变量是 final 的基本类型或字符串常量，值已确定，在准备阶段完成</li><li>static 变量是 final 的引用类型，赋值在初始化阶段完成</li></ul></li><li>连接-解析 <ul><li>把类中的符号引用转换为直接引用</li><li>解析之前需要对符号引用进行验证（连接-验证）</li></ul></li><li>初始化：对类的静态变量和静态代码块执行初始化操作 <ul><li>如果初始化一个类时，发现父类未初始化，优先初始化其父类</li><li>如果同时包含多个静态变量和静态代码块，按照自上而下的顺序执行</li></ul></li><li>使用</li><li>卸载</li></ol><h2 id="对象什么时候可以被垃圾回收器回收" tabindex="-1"><a class="header-anchor" href="#对象什么时候可以被垃圾回收器回收" aria-hidden="true">#</a> 对象什么时候可以被垃圾回收器回收？</h2><p>如果对象没有任何引用指向它时，那么认为这个对象是垃圾；如果定位了垃圾，就可能被垃圾回收器回收。</p><h3 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a> 引用计数法</h3><blockquote><p>给对象添加一个引用计数器，每当有引用到这个对象时，计数器加一；当引用失效时，计数器减一；当引用计数器为 0 时对象可以被回收。</p></blockquote><p><strong>弊端</strong>：当两个对象出现循环引用时，由于它们相互引用对方，导致引用计数器永不为 0，因此无法被垃圾回收，造成内存泄漏。</p><h3 id="可达性分析算法" tabindex="-1"><a class="header-anchor" href="#可达性分析算法" aria-hidden="true">#</a> 可达性分析算法</h3><blockquote><p>以 GC Roots 对象为起点进行搜索，能够达到的对象就需要保留，不可达的对象（即对象和 GC Roots 没有任何引用链相连）就可以被回收。</p></blockquote><p><strong>哪些对象可以作为 GC Roots</strong>：</p><ul><li>虚拟机栈中引用的对象，包括各个线程的栈帧中的本地变量表中的对象、方法调用中传递的参数和返回值等。</li><li>方法区中类静态属性引用的对象，这些对象随着类一起加载，直到类被卸载才会被销毁。</li><li>方法区中常量引用的对象，如字符串常量池中的字符串对象，它们也是被类加载器加载的时候创建的，因此可以看作是类的一部分。</li><li>本地方法栈中 JNI 引用的对象，这些对象通常由本地方法库创建和销毁。</li><li>Java 虚拟机内部的基本对象类型对应的 Class 对象，如 int.class、float.class 等。</li></ul><h2 id="常见的垃圾回收算法有几种类型-他们对应的优缺点是什么" tabindex="-1"><a class="header-anchor" href="#常见的垃圾回收算法有几种类型-他们对应的优缺点是什么" aria-hidden="true">#</a> 常见的垃圾回收算法有几种类型？他们对应的优缺点是什么？</h2><h3 id="标记清除算法" tabindex="-1"><a class="header-anchor" href="#标记清除算法" aria-hidden="true">#</a> 标记清除算法</h3><blockquote><p>标记存活的对象，在标记完成后统一清除没有标记过的对象（将该对象所占用内存的起始结束地址记录到空闲地址列表）。</p></blockquote><p>优点：简单直接，速度较快</p><p>缺点：会产生大量不连续的内存碎片，可能无法给大对象分配足够的内存，导致内存溢出</p><h3 id="标记整理算法" tabindex="-1"><a class="header-anchor" href="#标记整理算法" aria-hidden="true">#</a> 标记整理算法</h3><blockquote><p>标记存活的对象，将存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p></blockquote><p>优点：不会产生内存碎片</p><p>缺点：整理时需要进行对象的移动，效率比较低</p><h3 id="复制算法" tabindex="-1"><a class="header-anchor" href="#复制算法" aria-hidden="true">#</a> 复制算法</h3><blockquote><p>将内存划分为大小相等的两块，每次只使用其中一块。垃圾回收时，将存活的对象复制到另一块上，然后将原先使用的内存空间一次清理掉。</p></blockquote><p>优点：简单高效，不会产生内存碎片</p><p>缺点：只使用了一半内存</p><h3 id="分代收集算法" tabindex="-1"><a class="header-anchor" href="#分代收集算法" aria-hidden="true">#</a> 分代收集算法</h3><blockquote><p>现在虚拟机的垃圾回收采用的是分代收集算法：根据对象存活周期的不同将内存分成几块，不同块选择各自合适的垃圾回收算法。</p></blockquote><p><strong>一般把堆分成新生代和老年代</strong></p><ul><li><p>新生代</p><ul><li><p>存放寿命短的对象</p></li><li><p>新生代分为一块较大的 Eden 区和两块较小的 Survivor 区（ From 区和 To 区，也称 S0 和 S1 )</p></li><li><p>垃圾回收采用的是<strong>复制算法</strong></p><p>首先，把 Eden 区和 From 区中存活的对象复制到 To 区域（如果 To 区空间不足，会通过<strong>分配担保机制</strong>把对象移动到老年代），同时把这些对象年龄加 1；如果对象年龄达到阈值，则会晋升到老年代；然后，清空 Eden 区和 From 区的对象；最后，交换 From 区和 To 区，即原 To 区会成为下次 GC 时的 From 区。</p></li></ul></li><li><p>老年代</p><ul><li>存放长时间存活的对象</li><li>垃圾回收采用的是 标记清除算法 或 标记整理算法</li></ul></li></ul><p>优点：能针对不同的情况选择最合适的垃圾回收算法</p><p>缺点：实现较为复杂</p>',32);function c(h,n){const i=t("Mermaid");return e(),o("div",null,[d,r(i,{id:"mermaid-58",code:"eJxLL0osyFBwCuFyys8vKS4B8pxzEouLffITU1KLop9OWP+0a8Xzjbufdi14sXfv05krYrlcK0qQlTzrXPl041RUJY4FqKbsmvJ8yornK7qf7upHVehcWlySn4us9kX7qqfrZj3Z2UlAoYKurp0Cqj1gIVTXgYWw+YwLAHEkdxs="}),p])}const b=a(s,[["render",c],["__file","JVM.html.vue"]]);export{b as default};
