import{_ as r,Y as e,Z as a,a1 as t}from"./framework-5e11dbd9.js";const n={},s=t('<h2 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则" aria-hidden="true">#</a> 单一职责原则</h2><p>单一职责原则（SRP），<strong>就一个类来说，应该仅有一个引起它变化的原因。</strong></p><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响这个类完成其他职责的能力。这种耦合是一种脆弱的设计，当变化发生时，都可能会受到意想不到的破坏。</p><p>在软件设计中，需要发现职责并把这些职责相互分离，封装在不同的类中。如果能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。也就是说，将不同的变化原因封装到不同的类中，如果多个职责总是同时发生改变也可以把它们封装到同一个类中。</p><p>对于我们编程来说，要在类的职责分离上多思考，尽量做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。</p><h2 id="开放-封闭原则" tabindex="-1"><a class="header-anchor" href="#开放-封闭原则" aria-hidden="true">#</a> 开放-封闭原则</h2><p>开放-封闭原则（OCP），是说<strong>软件实体（类、模块、函数等）应该可以扩展，但不可以修改</strong>。即对<strong>扩展开放，对修改封闭</strong>。</p><p>要满足开闭原则，抽象化是关键。我们在最初编写代码时，先假设变化不会发生。当变化发生时，可以创建抽象来应对以后发生的同类变化。如果需要修改系统的行为，无须对现有的代码进行改动，而是增加新的实现类来实现新的业务功能。</p><p>开闭原则是面向对象设计的核心所在。遵循这个原则可以给系统带来更好的可维护性、可扩展性、可复用性和灵活性。开发人员应该对程序中频繁变化的那些部分做出抽象。然而，不要刻意地程序的每个部分进行抽象，拒绝不成熟的抽象和抽象本身一样重要。</p><h2 id="依赖倒转原则" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则" aria-hidden="true">#</a> 依赖倒转原则</h2><p>依赖倒转原则（DIP），就是<strong>抽象不应该依赖细节，细节应该依赖于抽象</strong>。即要<strong>针对接口编程，不要对实现编程</strong>。</p><p>在软件设计中，高层模块不应该依赖低层模块，并且不管是高层模块还是低层模块，它们都要依赖于抽象。即尽量使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，这样可以在不修改的情况下扩展系统的功能，而且无论高层模块还是低层模块都可以很容易地被复用。</p><p>依赖倒转其实可以说是面向对象设计的标志，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或接口，那就是面向对象的设计，反之那就是过程化的设计。</p><h2 id="里式代换原则" tabindex="-1"><a class="header-anchor" href="#里式代换原则" aria-hidden="true">#</a> 里式代换原则</h2><p>里式代换原则（LSP），<strong>子类必须能够替换掉它们的父类型</strong>。<strong>一个软件实体如果使用的是一个父类的话，那么一定可以使用其子类，而且它察觉不出父类对象和子类对象的区别</strong>。也就是说，<strong>在软件里面，把父类都替换成它的子类，程序的行为没有变化</strong>。</p><p>只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能在父类的基础上增加新的行为。也正是由于子类型的可替换性才使得使用父类型的模块在无须修改的情况下就可以扩展。即由于有里式代换原则，才使得开放-封闭成为可能。</p>',16),o=[s];function p(h,i){return e(),a("div",null,o)}const c=r(n,[["render",p],["__file","Principles.html.vue"]]);export{c as default};
