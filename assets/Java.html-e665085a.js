import{_ as o,Y as p,Z as i,$ as s,a0 as n,a2 as e,a1 as a,E as r}from"./framework-5e11dbd9.js";const c={},t=a('<h2 id="jdk、jre-和-jvm-分别是什么-有什么区别" tabindex="-1"><a class="header-anchor" href="#jdk、jre-和-jvm-分别是什么-有什么区别" aria-hidden="true">#</a> JDK、JRE 和 JVM 分别是什么？有什么区别？</h2><ul><li><p>JDK：Java 开发工具包，包含了 JRE 和 编译器、调试器和其它工具，用来开发 Java 应用程序（包括编译、调试和运行）；</p></li><li><p>JRE：Java 运行时环境，包含了 JVM 和 Java 核心类库，是运行已编译好的 Java 程序所需的环境；</p></li><li><p>JVM：Java 虚拟机，Java 字节码的运行环境，将字节码转换成可以在本机运行的机器码，是 Java 跨平台的关键。</p></li></ul><p><strong>区别：</strong></p><p>JVM 虽说是 Java 字节码的运行环境，但是当靠它是不足以执行 .class 文件，因为在解释 .class 文件时要调用解释需要的类库，这部分是在 JRE 中，所以 JRE 是运行 Java 程序所需的最小环境。</p><p>JRE 中没有 javac 命令，无法将 Java 文件编译成字节码文件，但它有 java 命令，可以直接运行字节码文件。而 JDK 除了包含 JRE 以外，还提供编译、调试工具等，如 javac（编译器，将源代码转成字节码）、jar（打包工具）、javadoc (文档生成器）、 jdb（debugger，查错工具）等。</p><h2 id="什么是字节码-采用字节码的最大好处是什么" tabindex="-1"><a class="header-anchor" href="#什么是字节码-采用字节码的最大好处是什么" aria-hidden="true">#</a> 什么是字节码？采用字节码的最大好处是什么？</h2><p>Java 代码经过 javac 编译后形成的 .class 文件就是字节码文件。</p><p>字节码只面向虚拟机，而虚拟机针对不同系统有不同的实现，保证使用相同的字节码能得到相同的结果，因此 Java 程序无需重新编译就可以在不同操作系统上运行。</p><h2 id="java-和-c-、go-语言的区别-各自的优缺点" tabindex="-1"><a class="header-anchor" href="#java-和-c-、go-语言的区别-各自的优缺点" aria-hidden="true">#</a> Java 和 C++、Go 语言的区别，各自的优缺点？</h2><p><strong>Java</strong>：适用于开发企业应用、Web 应用、移动应用等领域。</p><ul><li>优点： <ul><li>面向对象，支持封装、继承和多态</li><li>跨平台，一次编译就可以在不同操作系统上运行</li><li>安全性高，不提供指针来直接访问内存，有自动内存管理</li><li>有丰富的类库</li><li>支持多线程和网络编程</li></ul></li><li>缺点： <ul><li>编译与解释并存，运行速度相对较慢</li></ul></li></ul><p><strong>C++</strong>：适用于游戏、操作形态、嵌入式系统等领域。</p><ul><li>优点： <ul><li>面向对象，支持封装、继承和多态</li><li>编译型语言，速度快</li><li>可直接操作硬件和内存</li></ul></li><li>缺点： <ul><li>需要手动释放内存</li></ul></li></ul><p><strong>Go</strong>：适用于开发高并发、分布式系统。</p><ul><li>优点： <ul><li>并发能力强，更方便实现并发编程</li><li>有自动内存管理</li></ul></li><li>缺点： <ul><li>生态系统不够完善，相比 Java 和 C++ 来说支持的库还是较少</li></ul></li></ul><h2 id="jdk-动态代理和-cglib-动态代理的区别是什么" tabindex="-1"><a class="header-anchor" href="#jdk-动态代理和-cglib-动态代理的区别是什么" aria-hidden="true">#</a> JDK 动态代理和 CGLIB 动态代理的区别是什么？</h2><ul><li><p><strong>JDK 动态代理</strong>底层是通过<strong>反射机制</strong>来生成代理类，<strong>只能对实现接口的类进行代理</strong></p></li><li><p><strong>CGLIB 动态代理</strong>底层是利用<strong>ASM</strong>修改字节码生成目标类的子类，由于是采用<strong>继承</strong>，<strong>不能代理被 final 修饰的类或方法</strong></p></li><li><p>JDK 8 以后，<strong>JDK 动态代理效率高于 CGLIB 动态代理</strong>，并且，每一次 JDK 版本升级，JDK 动态代理效率都得到提升</p></li></ul><p><strong>在 SpringAOP 中，默认当目标类有实现接口时是通过 JDK 代理实现的，只有非实现类才通过 CGLIB 代理实现的（当然，可以通过设置强制使用 CGLIB）。</strong></p><h2 id="java-中-final-关键字有什么用" tabindex="-1"><a class="header-anchor" href="#java-中-final-关键字有什么用" aria-hidden="true">#</a> Java 中 final 关键字有什么用？</h2><ol><li>final 修饰类：不允许被继承，类中所有方法隐式为 final。</li><li>final 修饰方法：不允许被重写，但可以被重载；private 方法隐式为 final。</li><li>final 修饰变量：不允许被修改，只能在声明或构造函数中赋值，且只能赋值一次。</li></ol><p><strong>好处：</strong></p><p>使用 final 修饰可以防止一些代码被修改，提高安全性；</p><p>使用 final 修饰的变量如果在编译期就能确定值的话会放入常量池，可以提高程序的性能。</p><h2 id="java-中-hashcode-和-equals-方法是什么-它们和-各有什么区别" tabindex="-1"><a class="header-anchor" href="#java-中-hashcode-和-equals-方法是什么-它们和-各有什么区别" aria-hidden="true">#</a> Java 中 hashCode 和 equals 方法是什么？它们和 == 各有什么区别？</h2><p>hashCode：Object 类的方法，用于获取对象的哈希码，返回的类型是<code>int</code>。</p><p>equals：Object 类的方法，用于比较两个对象是否相等，默认情况下用<code>==</code>来比较（比较的是对象内存地址，即是否指向同一个对象）。但大多数情况下要重写<code>equals</code>方法来比较两个对象的值是否相等（String 类中已重写了<code>equals</code>方法）。</p><p>hashCode 主要用于基于哈希表的集合，如 HashMap、HashSet 等。先通过<code>hashCode</code>函数得到对象的哈希值来判断对象加入的位置，以及是否存在相同哈希值的对象，如果有会调用<code>equals</code>方法来比较两个对象是否相同，相同则不会加入集合，不同的话会采用拉链法来解决哈希冲突，即将元素添加到对应散列桶的链表末尾。</p><p>总结：</p><p><strong>两个对象相等，它们的 hashCode 值一定相同；但两个对象的 hashCode 值相同，它们不一定相等</strong>。因此，重写 <code>equals</code> 方法的时候需要重写 <code>hashCode</code> 方法。</p><h2 id="什么是反射机制-说说反射机制的优缺点、应用场景" tabindex="-1"><a class="header-anchor" href="#什么是反射机制-说说反射机制的优缺点、应用场景" aria-hidden="true">#</a> 什么是反射机制？说说反射机制的优缺点、应用场景？</h2><p>反射机制就是在<strong>运行时获取类的所有属性和方法</strong>，并且能够<strong>创建对象</strong>和<strong>调用对象的属性和方法</strong>。</p><p><strong>优点：</strong></p><ul><li>通过反射可以动态创建对象，无需硬编码，提高程序的灵活性和可扩展性。</li><li>反射机制是实现框架技术的一个基础，如 Spring、Junit 等技术框架都用到了反射。</li></ul><p><strong>缺点：</strong></p><ul><li>降低程序性能：反射包括了一些动态类型，所以 JVM 无法对这些代码进行优化。并且，反射需要解析处理大量类信息，频繁调用比较影响性能。</li><li>安全问题：反射能够访问私有属性和方法</li></ul><h2 id="访问修饰符-public、private、protected-以及无修饰符-默认-时的区别" tabindex="-1"><a class="header-anchor" href="#访问修饰符-public、private、protected-以及无修饰符-默认-时的区别" aria-hidden="true">#</a> 访问修饰符 public、private、protected，以及无修饰符（默认）时的区别</h2><p>访问修饰符是为了控制类、接口、变量和方法的访问范围，从大到小分别为：public、protected、无修饰符、private</p><ul><li>public：允许任何类进行访问</li><li>protected：允许同包或子类进行访问</li><li>无修饰符（默认）：允许同包进行访问</li><li>private：允许本类进行访问，一般不修饰类（除非是内部类）</li></ul><blockquote><p>注：子类虽然无法直接访问父类的 私有（private）成员变量，但是可以通过父类提供的公共（public）或受保护（protected）成员方法来访问和修改这些成员变量</p></blockquote><h2 id="string-和-stringbuffer、stringbuilder-的区别是什么" tabindex="-1"><a class="header-anchor" href="#string-和-stringbuffer、stringbuilder-的区别是什么" aria-hidden="true">#</a> String 和 StringBuffer、StringBuilder 的区别是什么？</h2><p>String 和 StringBuffer、StringBuilder 都是 Java 中用于处理字符串的类。它们间的区别如下：</p><ol><li>可变性 <ul><li>String 是不可变的，String 类中用于保存字符串的字符数组是用 <code>private final</code> 修饰的，并且没有提供修改该数组的方法。此外，String 类是用 <code>final</code> 修饰的，避免了其他类继承而破坏其不可变。每次对 String 的修改都会生成一个新的 String 对象。</li><li>StringBuffer 和 StringBuilder 是可变的，可以对字符串本身进行修改。</li></ul></li><li>线程安全性 <ul><li>String 不可变，是线程安全的。</li><li>StringBuffer 对方法加了同步锁，是线程安全的。</li><li>StringBuilder 没有对方法进行加锁，是线程不安全的。但因为这点，StringBuilder 的效率要比 StringBuffer 的高。</li></ul></li></ol><p>因此，如果是不需要频繁修改的字符串，可以用 String；需要频繁修改的，如果是单线程，使用 StringBuilder，多线程下使用 StringBuffer。</p><h2 id="什么是-bio、nio、aio" tabindex="-1"><a class="header-anchor" href="#什么是-bio、nio、aio" aria-hidden="true">#</a> 什么是 BIO、NIO、AIO？</h2><p>BIO、NIO、AIO 是 Java 中三种不同的 IO 模型。</p><ul><li><p>BIO</p><ul><li>同步阻塞 IO 模型，基于字符流和字节流进行操作。</li><li>当应用程序调用 IO 操作时，该线程会一直阻塞，直到处理完成。</li><li>适用于连接数比较小且固定的架构，对服务器资源要求比较高，程序较为简单容易理解。</li></ul></li><li><p>NIO</p><ul><li>同步非阻塞 IO 模型，是面向缓存区、基于通道的 IO 操作。</li><li>数据都从通道（Channel）读取到缓冲区（Buffer），或从缓存区写入到通道中，并且通过选择器（Selector）来监听多个通道上的事件（如连接请求、数据到达等），因此使用单个线程就可管理多个请求。</li><li>适用于连接数目多且连接比较短的架构，比如聊天服务器、弹幕系统、服务器间通讯等，编程比较复杂。</li></ul></li><li><p>AIO</p><ul><li><p>异步非阻塞 IO 模型，基于事件和回调机制实现。</p></li><li><p>当应用程序发起 IO 请求后就直接返回，由操作系统完成 IO 操作后再通知相应的线程进行处理。</p></li><li><p>适用于连接数目多且连接比较长的架构，比如相册服务器，充分调用操作系统参与并发操作，相对于 NIO 更加复杂。</p></li></ul></li></ul>',46),D={href:"https://blog.csdn.net/qq_40378034/article/details/119710529",target:"_blank",rel:"noopener noreferrer"},d=a(`<h2 id="什么是内部类-内部类的分类有哪些-内部类的优点-内部类有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#什么是内部类-内部类的分类有哪些-内部类的优点-内部类有哪些应用场景" aria-hidden="true">#</a> 什么是内部类？内部类的分类有哪些？内部类的优点，内部类有哪些应用场景？</h2><p>内部类就是定义在另一个类的内部的类。内部类可以分为四种：</p><ul><li><p><strong>成员内部类</strong></p><ul><li>定义在类的内部，与成员变量和方法同级</li><li>可以访问外部类的所有属性和方法</li><li>实例化：<code>Outer.Inner inner = new Outer.new Inner();</code></li></ul></li><li><p><strong>静态内部类</strong></p><ul><li>定义在类的内部，用 <code>static</code> 修饰</li><li>可以访问外部类的静态属性和静态方法，不能直接访问外部类的非静态成员</li><li>实例化：<code>Outer.Inner inner = new Outer.Inner();</code></li></ul></li><li><p><strong>局部内部类</strong></p><ul><li>定义在方法内部，不能被 public、protected、private 和 static 修饰，但可以被 final 修饰</li><li>需要访问方法中的局部变量时，该变量必须被 final 修饰</li><li>只能在该方法中实例化和使用</li></ul></li><li><p><strong>匿名内部类</strong></p><ul><li>没有类名的内部类，隐式实现接口或继承父类，用于创建只使用一次的类</li><li>需要访问外部类中方法的形参或变量时，该属性必须被 final 修饰</li></ul></li></ul><p>内部类的优点：</p><ul><li>可以访问外部类的私有属性和方法</li><li>可以隐藏实现细节，不被其他类所见，具有良好的封装性</li><li>可以模拟多继承，解决了单继承的缺陷</li><li>可以实现对外部类的回调操作</li></ul><p>应用场景：</p><ul><li><p>当一个类只想被某个类使用，不允许其他类使用，可以设计为内部类</p><p>例如：数据库连接池就是使用内部类来实现连接池中的连接对象，避免了其他类的使用</p></li><li><p>一些多算法场合，需要我们决定使用哪种算法</p><p>例如：使用 <code>Arrays.sort(T[] a, Comparator c)</code> 自定义排序时，通常使用内部类来实现 <code>Comparator</code> 接口</p></li><li><p>当一个对象只需要在某个方法中使用，其他地方用不到时可以使用内部类</p><p>例如：创建线程时，可以使用匿名内部类来实现 <code>Runnable</code> 接口</p></li></ul><h2 id="java-线程包括哪些状态-状态之间是如何切换的" tabindex="-1"><a class="header-anchor" href="#java-线程包括哪些状态-状态之间是如何切换的" aria-hidden="true">#</a> Java 线程包括哪些状态？状态之间是如何切换的？</h2><ul><li><code>NEW</code>：初始状态，线程刚被创建但还没启动</li><li><code>RUNNABLE</code>：可运行状态，相当于操作系统中线程的就绪和运行状态</li><li><code>BLOCKED</code>：阻塞状态，等待获取对象锁，线程被阻塞</li><li><code>WAITING</code>：等待状态，无期限的等待其他线程的通知</li><li><code>TIMED_WAITING</code>：超时等待状态，等待其他线程的通知，超时后自动唤醒</li><li><code>TERMINATED</code>：终止状态，线程执行完毕或出现异常提前结束</li></ul><p>线程间状态的切换：</p><ol><li>通过 <code>new Thread()</code> 创建并初始化线程后，处于 <code>NEW</code> 初始状态</li><li>调用线程的 <code>start()</code> 方法，进入 <code>RUNNABLE</code> 可运行状态</li><li>当获取锁失败（如 <code>synchronized</code> 代码块）会使线程进入 <code>BLOCKED</code> 阻塞状态，等到获取锁成功才重新回到 <code>RUNNABLE</code> 可运行状态</li><li>当线程调用 <code>wait()</code> 方法会使线程进入到 <code>WAITING</code> 等待状态，需要等待其他线程的通知，如 <code>notify</code>()、<code>notifyAll()</code>，才能唤醒线程，进入 <code>RUNNABLE</code> 可运行状态</li><li>当线程调用 <code>wait(long)</code>、<code>sleep(long)</code> 等方法并设置了超时时间，则会进入 <code>TIMED_WAITING</code> 超时等待状态，需要等待其他线程的通知或超时时间到了才重新回到 <code>RUNNABLE</code> 可运行状态</li><li>当线程执行完毕或出现异常，进入 <code>TERMINATED</code> 终止状态</li></ol><h2 id="如何让几个线程按顺序执行" tabindex="-1"><a class="header-anchor" href="#如何让几个线程按顺序执行" aria-hidden="true">#</a> 如何让几个线程按顺序执行？</h2><p>方式一：利用 <code>join()</code> 方法</p><blockquote><p><code>join()</code>：等待调用该方法的线程执行结束</p></blockquote><p>示例：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#4EC9B0;">Thread</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;"> = </span><span style="color:#C586C0;">new</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Thread</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">-&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">System</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">out</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;t1&quot;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#4EC9B0;">Thread</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">t2</span><span style="color:#D4D4D4;"> = </span><span style="color:#C586C0;">new</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Thread</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">-&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">try</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">join</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#D4D4D4;">    } </span><span style="color:#C586C0;">catch</span><span style="color:#D4D4D4;"> (</span><span style="color:#4EC9B0;">InterruptedException</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">e</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">e</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">printStackTrace</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">System</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">out</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;t2&quot;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#4EC9B0;">Thread</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">t3</span><span style="color:#D4D4D4;"> = </span><span style="color:#C586C0;">new</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Thread</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">-&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">try</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">t2</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">join</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#D4D4D4;">    } </span><span style="color:#C586C0;">catch</span><span style="color:#D4D4D4;"> (</span><span style="color:#4EC9B0;">InterruptedException</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">e</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">e</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">printStackTrace</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#9CDCFE;">System</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">out</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;t3&quot;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9CDCFE;">t3</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">start</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#9CDCFE;">t2</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">start</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">start</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="notify-和-notifyall-的区别" tabindex="-1"><a class="header-anchor" href="#notify-和-notifyall-的区别" aria-hidden="true">#</a> notify() 和 notifyAll() 的区别</h2><p><code>notify()</code>：唤醒任意一个正在等待该对象锁的线程</p><p><code>notifyAll()</code>：唤醒所有等待该对象锁的线程</p><blockquote><p><code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法需要和 <code>synchronized</code> 配合使用，否则会抛出 <code>IllegalMonitorStateException</code> 异常。并且，调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法，需要等待当前线程执行完 <code>synchronized</code> 代码块或方法释放锁后，其他等待线程才能获取到锁。</p></blockquote><h2 id="wait-和-sleep-方法的区别" tabindex="-1"><a class="header-anchor" href="#wait-和-sleep-方法的区别" aria-hidden="true">#</a> wait() 和 sleep() 方法的区别</h2><p><code>wait()</code> 和 <code>sleep()</code> 都是会让线程进入等待或超时等待状态，它们间的区别如下：</p><ol><li><code>wait()</code> 是 Object 中的成员方法；<code>sleep()</code> 是 Thread 中的静态方法</li><li><code>wait()</code> 方法可以被 <code>notify()</code>、<code>notifyAll()</code> 方法提前唤醒；<code>sleep()</code> 需要等待时间到了才被唤醒</li><li>使用 <code>wait()</code> 方法时，当前线程必须拥有其对象锁，并在调用后会释放锁；而 <code>sleep()</code> 方法只是让线程暂停执行，并不会释放锁</li></ol><h2 id="如何停止正在运行的线程" tabindex="-1"><a class="header-anchor" href="#如何停止正在运行的线程" aria-hidden="true">#</a> 如何停止正在运行的线程？</h2><p>方式一：使用标志位，通过共享变量或标志位来控制线程的执行</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">public</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">Interrupt1</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">static</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">volatile</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">boolean</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">flag</span><span style="color:#D4D4D4;"> = </span><span style="color:#569CD6;">true</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">public</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">static</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">void</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">main</span><span style="color:#D4D4D4;">(</span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;">[] </span><span style="color:#9CDCFE;">args</span><span style="color:#D4D4D4;">) </span><span style="color:#569CD6;">throws</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">InterruptedException</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#4EC9B0;">Thread</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;"> = </span><span style="color:#C586C0;">new</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Thread</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">-&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">            </span><span style="color:#C586C0;">while</span><span style="color:#D4D4D4;"> (flag) {</span></span>
<span class="line"><span style="color:#D4D4D4;">                </span><span style="color:#9CDCFE;">System</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">out</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;线程正在执行...&quot;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">                </span><span style="color:#C586C0;">try</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">                    </span><span style="color:#9CDCFE;">Thread</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">sleep</span><span style="color:#D4D4D4;">(</span><span style="color:#B5CEA8;">500</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">                } </span><span style="color:#C586C0;">catch</span><span style="color:#D4D4D4;"> (</span><span style="color:#4EC9B0;">InterruptedException</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">e</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">                    </span><span style="color:#9CDCFE;">e</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">printStackTrace</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#D4D4D4;">                }</span></span>
<span class="line"><span style="color:#D4D4D4;">            }</span></span>
<span class="line"><span style="color:#D4D4D4;">        });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">start</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">Thread</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">sleep</span><span style="color:#D4D4D4;">(</span><span style="color:#B5CEA8;">1000</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">        flag = </span><span style="color:#569CD6;">false</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方式二：使用 <code>interrupt()</code> 方法</p><ul><li>通过 <code>isInterrupted()</code> 中断状态来判断线程是否退出</li><li>当中断阻塞的线程时（sleep、wait、join 等），会抛出 <code>InterruptedException</code> 异常</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#4EC9B0;">Thread</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;"> = </span><span style="color:#C586C0;">new</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Thread</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">-&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">while</span><span style="color:#D4D4D4;"> (!</span><span style="color:#9CDCFE;">Thread</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">currentThread</span><span style="color:#D4D4D4;">().</span><span style="color:#DCDCAA;">isInterrupted</span><span style="color:#D4D4D4;">()) {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">System</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">out</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;running...&quot;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">start</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#9CDCFE;">Thread</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">sleep</span><span style="color:#D4D4D4;">(</span><span style="color:#B5CEA8;">100</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">interrupt</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">// 中断阻塞线程</span></span>
<span class="line"><span style="color:#4EC9B0;">Thread</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">t2</span><span style="color:#D4D4D4;"> = </span><span style="color:#C586C0;">new</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Thread</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">-&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">try</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#C586C0;">while</span><span style="color:#D4D4D4;"> (!</span><span style="color:#9CDCFE;">Thread</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">currentThread</span><span style="color:#D4D4D4;">().</span><span style="color:#DCDCAA;">isInterrupted</span><span style="color:#D4D4D4;">()) {</span></span>
<span class="line"><span style="color:#D4D4D4;">            </span><span style="color:#9CDCFE;">System</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">out</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;running...&quot;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">            </span><span style="color:#9CDCFE;">Thread</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">sleep</span><span style="color:#D4D4D4;">(</span><span style="color:#B5CEA8;">3000</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">        }</span></span>
<span class="line"><span style="color:#D4D4D4;">    } </span><span style="color:#C586C0;">catch</span><span style="color:#D4D4D4;"> (</span><span style="color:#4EC9B0;">InterruptedException</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">e</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">System</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">out</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(e);</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9CDCFE;">t2</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">start</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#9CDCFE;">Thread</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">sleep</span><span style="color:#D4D4D4;">(</span><span style="color:#B5CEA8;">1000</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#9CDCFE;">t2</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">interrupt</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方式三：使用 <code>stop()</code> 方法（已过时），该方法可能会导致线程在执行过程中的资源泄漏或数据一致性的问题，并且，如果线程持有锁，也会导致锁无法释放，造成死锁。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#4EC9B0;">Thread</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;"> = </span><span style="color:#C586C0;">new</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">Thread</span><span style="color:#D4D4D4;">(() </span><span style="color:#569CD6;">-&gt;</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#C586C0;">while</span><span style="color:#D4D4D4;"> (</span><span style="color:#569CD6;">true</span><span style="color:#D4D4D4;">) {</span></span>
<span class="line"><span style="color:#D4D4D4;">        </span><span style="color:#9CDCFE;">System</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">out</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">println</span><span style="color:#D4D4D4;">(</span><span style="color:#CE9178;">&quot;running...&quot;</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#D4D4D4;">    }</span></span>
<span class="line"><span style="color:#D4D4D4;">});</span></span>
<span class="line"><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">start</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#9CDCFE;">Thread</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">sleep</span><span style="color:#D4D4D4;">(</span><span style="color:#B5CEA8;">500</span><span style="color:#D4D4D4;">);</span></span>
<span class="line"><span style="color:#9CDCFE;">t1</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">stop</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="synchronized-关键字是什么-有什么作用-底层原理了解吗" tabindex="-1"><a class="header-anchor" href="#synchronized-关键字是什么-有什么作用-底层原理了解吗" aria-hidden="true">#</a> synchronized 关键字是什么，有什么作用，底层原理了解吗？</h2><p><code>synchronized</code> 是 Java 中的关键字，用于实现同步，主要解决多个线程访问共享资源的同步性，保证<strong>同一时刻只有一个线程可以访问</strong>。</p><p><code>synchronized</code> 可以用于修饰方法和代码块：</p><ul><li>修饰方法： <ul><li>修饰实例方法：进入同步代码前要获取到<strong>当前对象实例的锁</strong></li><li>修饰静态方法：进入同步代码前要获取到<strong>当前类的锁</strong></li></ul></li><li>修饰代码块： <ul><li><code>synchronized(object)</code>：进入同步代码前要获取到<strong>指定对象的锁</strong></li><li><code>synchronized(类.class)</code>：进入同步代码前要获取到<strong>指定类的锁</strong></li></ul></li></ul><p><strong>底层原理</strong>：</p><p><code>synchronized</code> 的底层实现主要依赖于对象头的 <code>Mark Word</code>（标记字段）和 <code>monitor</code> 监视器。</p><blockquote><p>JVM 中，对象在内存中分为三个部分：</p><ul><li>对象头：存储对象自身的运行时数据</li><li>Mark Word（标记字段）：包含对象的 hashCode、GC 分代年龄、锁状态标志位、偏向锁标志位、持有偏向锁的线程 ID 等</li><li>Klass Pointer（类型指针）：指向对象所属类的元数据信息，用于确定该对象的类型</li><li>实例数据区：存储对象的实例变量</li><li>对齐填充：JVM 要求对象的大小必须是 8 字节的倍数，对齐填充所占的内存空间是用来填补空缺的</li></ul></blockquote><p>JVM 是基于 Monitor 对象（C++ 实现的）来实现重量级锁的。Monitor 中有三个比较重要的字段：owner、entryList、waitSet。</p><p>当线程尝试进入同步代码块时，会获取锁对象关联的 Monitor。</p><ol><li>如果 owner 为空，说明该对象没有被其他线程持有，可以进入。将 owner 的值设为当前线程，并将偏向锁标志位设为 1</li><li>如果锁已经被占用了，线程会被阻塞，并加入到 entryList 中</li><li>如果持有锁的线程调用 <code>wait()</code> 方法，会将 owner 置为 null，同时加入的 waitSet 中等待被唤醒</li></ol>`,41),y={href:"https://www.cnblogs.com/wffzk/p/16639472.html",target:"_blank",rel:"noopener noreferrer"},u=a('<h2 id="你是否了解过新版本的-java-特性-对-java-未来的发展有什么看法" tabindex="-1"><a class="header-anchor" href="#你是否了解过新版本的-java-特性-对-java-未来的发展有什么看法" aria-hidden="true">#</a> 你是否了解过新版本的 Java 特性？对 Java 未来的发展有什么看法？</h2><h3 id="java-8-新特性" tabindex="-1"><a class="header-anchor" href="#java-8-新特性" aria-hidden="true">#</a> Java 8 新特性</h3><ul><li>Lambda 表达式：支持函数式编程，简化匿名内部类</li><li>Optional 类：防止 NPE（空指针异常）</li><li>Stream 流：以流的方式检索和处理集合数据，如过滤、排序、映射等操作，还能并行化处理</li><li>接口的默认方法和静态方法：解决接口修改和原有的实现不兼容的问题</li><li>方法引用：使用 <code>::</code> 直接引用现有的方法或构造函数</li><li>日期和时间 API：引入了全新的日期和时间 API，它提供了一套丰富的类和方法来处理时间和日期相关的问题</li></ul><h3 id="java-9-新特性" tabindex="-1"><a class="header-anchor" href="#java-9-新特性" aria-hidden="true">#</a> Java 9 新特性</h3><ul><li>模块系统：允许将代码组织成相互独立的模块，从而提高代码的可维护性和安全性</li><li>JShell：交互式命令行工具，快速尝试代码片段</li><li>集合工厂方法：为 List、Set 和 Map 接口提供了一组新的静态工厂方法 <code>of()</code>，更方便地创建不可变集合对象</li><li>接口私有方法：允许在接口中定义私有方法，这些方法只能被接口中的其他方法所调用，从而使得接口的实现更加灵活</li><li>默认垃圾收集器：G1 成为默认的垃圾收集器</li></ul><h3 id="java-10-新特性" tabindex="-1"><a class="header-anchor" href="#java-10-新特性" aria-hidden="true">#</a> Java 10 新特性</h3><ul><li>局部变量类型推断：使用 <code>var</code> 声明局部变量，让编译器自动推断出变量的类型</li><li>应用类数据共享：允许多个 JVM 进程共享已经加载的类元数据，这样可以减少启动时间和内存占用</li><li>集合增强：为 List、Set 和 Map 提供了静态方法 <code>copyOf()</code> 来返回一个集合的不可变拷贝</li><li>G1 垃圾收集器的改进：G1 的 FullGC 改为并行的标记清除算法，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量</li></ul><h3 id="java-11-新特性" tabindex="-1"><a class="header-anchor" href="#java-11-新特性" aria-hidden="true">#</a> Java 11 新特性</h3><ul><li>HTTP Client API：提供了一个标准的 API，用于发送 HTTP 请求和接收响应。该 API 支持 HTTP/1.1 和 HTTP/2 协议</li><li>Lambda 参数的局部变量语法：允许在 Lambda 表达式中使用 <code>var</code> 进行参数声明</li><li>ZGC（实验性）：一种可伸缩的低延迟垃圾收集器，适合处理大型堆内存</li></ul><h3 id="java-12-新特性" tabindex="-1"><a class="header-anchor" href="#java-12-新特性" aria-hidden="true">#</a> Java 12 新特性</h3><ul><li>String 增强：<code>indent()</code> 实现字符串缩进，<code>transform()</code> 用来转变指定字符串</li><li>Shenandoah GC（实验性）：一种实时垃圾收集器，可以在非常短的停顿时间内处理大型堆内存</li><li>Switch 表达式（Preview）：增强了 switch 语句，支持表达式形式，可以更好地支持模式匹配</li><li>instanceof 模式匹配（Preview）：在判断是否属于具体的类型同时完成转换</li></ul><h3 id="java-13-新特性" tabindex="-1"><a class="header-anchor" href="#java-13-新特性" aria-hidden="true">#</a> Java 13 新特性</h3><ul><li>Switch 表达式（Preview）：继续增强了 switch 语句，支持更复杂的表达式形式</li><li>Text Blocks（Preview）：引入了一种新的多行字符串语法，可以简化代码中的字符串拼接操作</li><li>ZGC 改进：ZGC 得到了一些改进，包括针对引用对象的指针重定位，以及更好的压缩机制</li></ul><h3 id="java-14-新特性" tabindex="-1"><a class="header-anchor" href="#java-14-新特性" aria-hidden="true">#</a> Java 14 新特性</h3><ul><li>Switch 表达式：正式引入了新的 switch 表达式语法，支持 Lambda 表达式和块语句</li><li>空指针异常精确提示：添加 <code>-XX:+ShowCodeDetailsInExceptionMessages</code> JVM 参数，能准确定位到出现 NPE 的变量，打印详细信息</li><li>record 关键字（Preview）：类声明语法，可以用来声明不可变值类型，自动生成获取属性的访问方法、toString()、hashCode()、equals() 方法</li><li>Text Blocks（Preview）：新增两个转义符 <code>\\</code> 和 <code>\\s</code></li></ul><h3 id="java-15-新特性" tabindex="-1"><a class="header-anchor" href="#java-15-新特性" aria-hidden="true">#</a> Java 15 新特性</h3><ul><li>Text Blocks：正式引入文本块，简化跨多行字符串编码问题</li><li>EdDSA 数字签名算法：基于 Edwards-Curve 数字签名算法（EdDSA）实现加密签名，具有更高的安全性和性能，但不会完全替代 ECDSA</li><li>Hidden Classes 隐藏类：不能直接被其他类的字节码使用，只能在运行时生成类并通过反射间接使用它们</li><li>Sealed Classes（Preview）：密封类，可以指定只允许某些类继承</li><li>ZGC：正式引入 ZGC（可伸缩低延迟垃圾收集器）</li></ul><h3 id="java-16-新特性" tabindex="-1"><a class="header-anchor" href="#java-16-新特性" aria-hidden="true">#</a> Java 16 新特性</h3><ul><li>inferfaceof 模式匹配（正式版）：使用 instanceof 来匹配对象类型，并且可以将匹配到的对象转换为指定类型</li><li>record（正式版）： Records 正式版，一个全新的类声明方式，用于定义只包含数据（而不包含业务逻辑）的类。Records 可以帮助简化代码，并提高可读性和可维护性</li><li>Vector API（实验性）：引入了一个新的 API，可以处理向量数据并利用硬件加速。该 API 可以提高运行效率，并使代码更易于编写和阅读</li></ul><h3 id="java-17-新特性" tabindex="-1"><a class="header-anchor" href="#java-17-新特性" aria-hidden="true">#</a> Java 17 新特性</h3><ul><li>Sealed Classes：正式版，该特性允许开发者限制一个类的子类数量和类型，从而提高代码安全性和可维护性</li><li>增强的伪随机数生成器：为伪随机数生成器（PRNG） 提供新的接口类型和实现，方便替换不同 PRNG 算法</li><li>switch 的类型匹配（Preview）：增加了类型匹配自动转换功能</li><li>外部函数和内存 API（孵化）：引入了一个新的 API，允许 Java 代码与非 Java 代码进行交互，包括 C 或 C++ 代码</li></ul><h3 id="java-未来发展的看法" tabindex="-1"><a class="header-anchor" href="#java-未来发展的看法" aria-hidden="true">#</a> Java 未来发展的看法</h3>',22);function C(v,h){const l=r("ExternalLinkIcon");return p(),i("div",null,[t,s("blockquote",null,[s("p",null,[s("a",D,[n("BIO、NIO、AIO详解"),e(l)])])]),d,s("blockquote",null,[s("p",null,[s("a",y,[n("https://www.cnblogs.com/wffzk/p/16639472.html"),e(l)])])]),u])}const g=o(c,[["render",C],["__file","Java.html.vue"]]);export{g as default};
