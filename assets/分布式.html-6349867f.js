import{_ as e,Y as a,Z as n,$ as t,a0 as l,a2 as o,a1 as i,E as s}from"./framework-5e11dbd9.js";const d={},p=i('<h2 id="什么是分布式-为什么需要分布式" tabindex="-1"><a class="header-anchor" href="#什么是分布式-为什么需要分布式" aria-hidden="true">#</a> 什么是分布式？为什么需要分布式？</h2><p>分布式是指将一个大型系统分解成多个独立的、可以单独运行的子系统，这些子系统可以在不同的计算机上运行，并通过网络进行通信。</p><p><strong>为什么需要分布式？</strong></p><ul><li><strong>提高系统的可用性和可扩展性</strong>：分布式系统可以将数据和计算能力分布在不同的节点上，从而提高系统的可用性和可扩展性。当系统的某个节点出现故障时，其他节点可以接管其工作，从而保证系统的正常运行。</li><li><strong>支持大规模数据处理和高并发访问</strong>：分布式系统可以将数据和计算能力分布在多台服务器上，从而支持大规模数据处理和高并发访问。</li><li><strong>提高系统的性能和处理能力</strong>：分布式系统可以将任务分配到不同的节点上并行处理，从而提高系统的性能和处理能力。</li></ul><h2 id="什么是网关-网关有哪些作用" tabindex="-1"><a class="header-anchor" href="#什么是网关-网关有哪些作用" aria-hidden="true">#</a> 什么是网关，网关有哪些作用？</h2><p>网关就是连接两个不同网络的设备或服务。网关的作用包括：</p><ul><li>连接转发：连接不同网络的主机，进行数据传输</li><li>协议转换：将不同类型的协议进行翻译转换，帮助不同的主机进行数据交换</li><li>API管理：通过 API 网关拦截所有 API 请求，从而更好地管理，如身份认证、过滤、限流、负载均衡、熔断降级等</li></ul><h2 id="dubbo-是什么-是否了解过它的架构设计" tabindex="-1"><a class="header-anchor" href="#dubbo-是什么-是否了解过它的架构设计" aria-hidden="true">#</a> Dubbo 是什么？是否了解过它的架构设计？</h2><p>Apache Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下服务之间的通信问题，并利用 Dubbo 提供的丰富服务治理特性，可以实现如服务发现、负载均衡、流量调度等服务治理需求。</p><p>Dubbo 的总体架构：</p><figure><img src="https://cn.dubbo.apache.org/imgs/user/dubbo-architecture.jpg" alt="dubbo-architucture" tabindex="0" loading="lazy"><figcaption>dubbo-architucture</figcaption></figure><p>Dubbo 架构设计中包括了五个角色，分别是：container（服务运行容器）、provider（服务提供者，暴露服务）、consumer（服务消费者，调用远程服务）、registry（注册中心，服务注册与发现）、monitor（监控中心，统计服务调用次数和调用时间）。它们间调用关系如下：</p><ol start="0"><li>服务容器负责启动、加载、运行服务提供者</li><li>服务提供者启动时，向注册中心注册自己提供的服务</li><li>服务消费者启动时，向注册中心订阅自己需要的服务</li><li>注册中心返回服务提供者的地址列表给消费者，如发生变更，会基于长连接推送变更数据给消费者</li><li>服务消费者从提供者地址列表中，通过软负载均衡算法选取一台提供者进行调用，若调用失败再选其他提供者</li><li>消费者和提供者会在内存中累计调用次数和调用时间，定时每分钟向监控中心发送一次统计数据</li></ol><h2 id="什么是分布式的-cap-理论" tabindex="-1"><a class="header-anchor" href="#什么是分布式的-cap-理论" aria-hidden="true">#</a> 什么是分布式的 CAP 理论？</h2><p>CAP 理论是指一个分布式系统中，不可能同时满足以下三个条件：</p><ul><li><strong>一致性（Consistency）</strong>：所有节点在同一时间的看到的数据是一致的，即写数据操作时要同时更新相关副本，保证强一致性</li><li><strong>可用性（Availability）</strong>：系统中能正常接收请求的节点都能在合理时间内返回结果，即系统在某些节点失效下仍能对外提供服务</li><li><strong>分区容错性（Partition Tolerance）</strong>：什么是分区？分布式系统中存在很多节点，这些节点之间通过网络进行通信，当节点间的通信出了问题（如网络故障、机器故障等），就称系统出现了分区。而分区容错性就是出现分区问题时，系统还能继续对外提供服务</li></ul><p>根据 CAP 理论，分布式系统只能满足其中的两个特性。然而实际上，分区容错性是一定要满足的，因为不可能只要出现分区问题时整个系统就完全无法使用。因此，在分布式系统中，我们需要考虑的是当出现分区问题时，选择的是一致性还是可用性，即 CP 还是 AP。</p><ul><li>CP 架构：当系统出现分区故障时，客户端发送的任意请求都会被卡死或超时，保证数据的强一致性。如 Zookeeper</li><li>AP 架构：当系统出现分区故障时，客户端依旧能获取数据，但有的是新数据，有的是旧数据。如 Eureka</li></ul>',18),g={href:"https://cloud.tencent.com/developer/article/1860632",target:"_blank",rel:"noopener noreferrer"},u=i('<h2 id="什么是-rpc-目前有哪些常见的-rpc-框架-实现-rpc-框架的核心原理是什么" tabindex="-1"><a class="header-anchor" href="#什么是-rpc-目前有哪些常见的-rpc-框架-实现-rpc-框架的核心原理是什么" aria-hidden="true">#</a> 什么是 RPC？目前有哪些常见的 RPC 框架？实现 RPC 框架的核心原理是什么？</h2><p>RPC（Remote Procedure Call）：远程过程调用，允许不同服务之间相互调用，就像跟调用本地方法一样简单。RPC 帮助我们将网络通信细节封装起来，让分布式应用中各个模块间的通信更加简单。</p><p>常见的 RPC 框架有：Google 的 gRPC、FaceBook 的 Thrift、Apache 的 Dubbo 等。</p><p>实现 RPC 框架的核心原理是：</p><ol><li>定义接口：定义需要远程调用方法的接口，包括请求参数和返回类型等信息</li><li>序列化和反序列化：将请求参数和返回结果等数据进行序列化和反序列化，使数据能在网络中传输</li><li>网络通信：通过网络协议（如 TCP/IP 等）实现客户端和服务端的通信，并传输序列化后的请求和相应数据</li><li>代理对象：为了方便调用远程方法，会提供一个本地代理对象，封装远程调用的细节，隐藏网络通信的复杂性</li><li>调用远程方法：客户端通过代理对象调用远程方法，代理对象将参数序列化并传输到服务端，服务端收到请求后将参数反序列化并执行方法，将结果反序列化并发送客户端</li><li>容错和优化：为保证系统的可靠性和性能，需要提供超时重试、负载均衡、缓存等容错和优化手段</li></ol><h2 id="什么是注册中心-如何实现一个注册中心" tabindex="-1"><a class="header-anchor" href="#什么是注册中心-如何实现一个注册中心" aria-hidden="true">#</a> 什么是注册中心？如何实现一个注册中心？</h2><p>注册中心是<strong>分布式或微服务系统</strong>中<strong>用于服务注册和发现</strong>的重要组件，充当服务提供者和服务消费者的中介，服务提供者可以将要提供的服务注册到注册中心上，服务消费者通过注册中心来发现可用的服务提供者，并调用提供的服务。</p><p>实现注册中心的核心在于数据存储、服务注册、服务发现、健康检测等功能。</p><ol><li>数据存储：注册中心需要存储和维护服务实例、元数据信息和路由规则等信息，可以使用关系型数据库或者轻量级的键值存储系统作为数据存储</li><li>服务注册：服务提供者向注册中心提供服务名、IP 地址、端口以及元数据信息等进行注册，方便消费方获取信息和服务调用</li><li>服务发现：服务消费者向注册中心拉取服务列表，并在本地进行信息的缓存。当注册中心的服务发生变更时，需要通知消费者重新拉取服务列表。为了防止出现网络波动等导致通知失败，消费者还需要定时向注册中心拉取并更新服务列表</li><li>健康检测：健康检测是为了确保注册到注册中心的服务节点是正常的，避免无效节点造成资源的浪费。服务节点通过客户端向注册中心上报心跳，表明自己还存活着。如果服务节点内部出现死锁或者假死，依旧可以上报心跳。因此，服务提供者向注册中心注册时，还要注册一个用于进行检测的服务内部接口</li></ol><p>在实际开发中，如果需要用到注册中心时，更多会采用比较成熟的技术方案，如 Zookeeper、Eureka、Consul、Nacos 等</p>',10),h={href:"https://juejin.cn/post/6959144127355158542",target:"_blank",rel:"noopener noreferrer"},c=i('<h2 id="什么是分布式的-base-理论-它与-cap-理论有什么联系" tabindex="-1"><a class="header-anchor" href="#什么是分布式的-base-理论-它与-cap-理论有什么联系" aria-hidden="true">#</a> 什么是分布式的 BASE 理论，它与 CAP 理论有什么联系？</h2><p>BASE 理论包括三个概念：</p><ul><li>基本可用（Basically Available）：系统在出现故障或网络分区等情况下，仍能保证基本的功能和服务，即使牺牲一定的功能完整性和数据一致性，核心功能和服务必须正常运行</li><li>软状态（Soft State）：软状态是指系统中数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。也就是说，允许系统在不同节点的数据副本间进行数据传输时存在一定的延时或不一致，但最终数据必须保持一致</li><li>最终一致性（Soft State）：经过一段时间后，所有数据副本都要达到一致的状态</li></ul><p>CAP 理论指在分布式系统下，一致性、可用性和分区容错性只能同时满足其中的两项。而 BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性，但应用可以根据自身的业务特点，采用适当的方式让系统达到最终一致性，从而获取更好的可用性和分区容错性。</p><h2 id="什么是消息队列-消息队列有哪些应用场景" tabindex="-1"><a class="header-anchor" href="#什么是消息队列-消息队列有哪些应用场景" aria-hidden="true">#</a> 什么是消息队列？消息队列有哪些应用场景？</h2><p>消息队列是一种用于在应用程序之间传递消息的软件机制。它可以用来实现应用之间的异步通信，可以解决负载平衡问题，也可以用来实现可靠的消息传递。</p><p>消息队列比较核心的应用场景有：解耦、异步和削峰。</p><ul><li><p>解耦：一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，如果将来有新的系统接入，就需要修改调用代码，并且维护起来很麻烦。通过将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而提供消息的系统不需要做任何修改，实现了系统之间的解耦。</p></li><li><p>异步：在传统模式下，一些非必要的业务逻辑以同步的方式运行，这样会耗费大量时间。而使用消息队列可以将这些非必要的业务逻辑以异步的方式运行，从而提高系统的性能。</p></li><li><p>削峰：在高并发的场景下，系统可能会瞬间接收到大量的请求，这时系统的负载会急剧上升，可能会导致系统崩溃。而使用消息队列可以将这些请求在一段时间内缓冲起来，系统根据自己的能力去拉取，从而达到削峰的效果。</p></li></ul><h2 id="有哪些主流的消息队列-它们分别有什么优缺点、各自的适用场景是什么" tabindex="-1"><a class="header-anchor" href="#有哪些主流的消息队列-它们分别有什么优缺点、各自的适用场景是什么" aria-hidden="true">#</a> 有哪些主流的消息队列，它们分别有什么优缺点、各自的适用场景是什么？</h2><ol><li><p>ActiveMQ：基于 JMS（Java 消息服务）的开源消息队列系统</p><p>优点：</p><ul><li>支持多种协议，如 AMQP、STOMP、REST、WebSocket 等</li><li>配置和部署相对简单，易于使用和维护</li><li>可靠性高，通过消息确认机制保证消息的可靠性</li></ul><p>缺点：</p><ul><li>性能相对于其他消息队列较低</li><li>处理大量并发连接时可能会出现一些问题</li></ul><p>适用场景：</p><ul><li>各种类型的消息传输场景，包括点对点模式和发布/订阅模式</li><li>需要简单易用且具有良好可靠性的消息传输场景，如企业内部通信和物联网设备通信</li></ul></li><li><p>RabbitMQ：使用 Erlang 语言实现的基于 AMQP（高级消息队列协议）的开源消息队列系统</p><p>优点：</p><ul><li>丰富的功能和插件支持</li><li>可靠性高，使用持久化、消息确认等机制保证消息的可靠性</li><li>灵活的路由机制适合处理复杂的消息传输场景</li></ul><p>缺点：</p><ul><li>配置和部署相对较为复杂</li></ul><p>适用场景：</p><ul><li>处理复杂的消息传输场景，如发布/订阅模式和工作队列模式</li><li>需要可靠性高的消息传输场景，如金融交易和电子商务领域</li></ul></li><li><p>RocketMQ：采用 Java 语言实现的分布式消息系统，由阿里巴巴集团开发</p><p>优点：</p><ul><li>高性能，支持每秒百万级的消息传输</li><li>可靠性高，通过多副本机制保证消息的可靠性</li><li>支持水平扩展，在节点之间进行无需停机的水平扩展</li></ul><p>缺点：</p><ul><li>社区生态相对较小，文档及教程不够完善</li></ul><p>适用场景：</p><ul><li>大规模数据传输场景，如日志收集和实时流处理</li><li>需要高吞吐量和低延迟的消息传输场景，如在线游戏和社交网络</li></ul></li><li><p>Redis：可利用 List、发布/订阅模式、Stream 流实现消息队列</p><p>优点：</p><ul><li>简单易用，开发效率高</li><li>基于内存存储，速度快</li></ul><p>缺点：</p><ul><li>功能相对简单，不适合处理复杂的消息传输场景</li></ul><p>适用场景：</p><ul><li>作为任务队列，将需要异步处理的任务放入队列，由后台工作线程进行处理</li><li>适用于需要实时响应的场合，如游戏中的消息传输</li></ul></li><li><p>Kafka：开源的一个分布式流式处理平台，适用于大规模数据处理和实时流数据应用场景</p><p>优点：</p><ul><li>高吞吐量，可以支持每秒数百万条消息的读写</li><li>可伸缩性强，可以轻松地扩展到集群模式，增加更多的 Broker 来处理更大规模的数据</li><li>提供实时流数据处理功能，可以满足需要快速响应的实时应用程序的需求</li></ul><p>缺点：</p><ul><li>Kafka 的配置和部署相对较复杂</li><li>Kafka 在运行时对 ZooKeeper 有强依赖，需要保证其稳定性，否则可能导致 Kafka 集群不可用</li></ul><p>适用场景：</p><ul><li><p>流式数据处理：Kafka 提供了实时流数据处理功能，可以将数据从生产者传输到消费者，并进行处理和转换</p></li><li><p>日志收集：Kafka 可以用作日志收集工具，将应用程序、服务器等的日志收集到一个中央位置，以便进行监控和问题排查</p></li></ul></li></ol><table><thead><tr><th>消息队列</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Redis</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10 万级，支持高吞吐</td><td>万级</td><td>10 万级，支持高吞吐</td></tr><tr><td>时效性</td><td>毫秒级</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒级</td></tr><tr><td>可用性</td><td>高，支持主从复制、集群模式</td><td>高，支持主从复制、集群模式</td><td>非常高，采用分布式架构，通过数据分区来实现负载均衡</td><td>高，支持主从复制、集群模式</td><td>非常高采用分布式架构，通过数据分区和副本机制来实现高可用性</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到零丢失</td><td>有较低的概率丢失数据</td><td>经过参数优化配置，可以做到零丢失</td></tr></tbody></table><p>总体来说，这些消息队列系统都具有各自的优势和适用场景。</p><ul><li>如果需要处理大量数据并且要求低延迟、高可靠性，可以选择 Kafka；</li><li>如果需要快速开发、易于部署，并且不需要处理大规模数据，则可以选择 ActiveMQ 或 RabbitMQ；</li><li>如果需要在高并发情况下表现出色，则可以考虑 RocketMQ；</li><li>如果已经使用了Redis作为缓存，并且希望通过消息队列实现更多功能，则可以考虑 Redis 作为消息队列。</li></ul><h2 id="有哪些常见的消息队列模型-分别适用于什么场景" tabindex="-1"><a class="header-anchor" href="#有哪些常见的消息队列模型-分别适用于什么场景" aria-hidden="true">#</a> 有哪些常见的消息队列模型？分别适用于什么场景？</h2><ol><li><strong>点对点模型</strong>（Point-to-Point Model）：这种模型中，<strong>消息生产者</strong>将消息发送到一个<strong>队列</strong>中，<strong>消息消费者</strong>从该队列中接收消息。<strong>一个消息只会被一个消费者接收</strong>，消费者在处理完消息之后会从队列中删除它。这种模型适用于<strong>需要保证消息只被一个消费者处理的场景</strong>，例如<strong>订单系统、日志处理</strong>等。</li><li><strong>发布-订阅模型</strong>（Publish-Subscribe Model）：这种模型中，<strong>消息生产者</strong>将消息发送到一个<strong>主题（Topic）<strong>中，多个</strong>消息消费者</strong>可以<strong>订阅</strong>该主题并接收到所有的消息。<strong>每个消息可以被多个消费者接收</strong>，消费者在处理完消息之后不会从主题中删除它。这种模型适用于<strong>需要将消息广播给多个消费者的场景</strong>，例如<strong>新闻订阅</strong>、<strong>实时数据分析</strong>等。</li><li><strong>请求-应答模型</strong>（Request-Response Model）：这种模型中，<strong>消息生产者</strong>发送一个请求消息到一个队列中，<strong>消息消费者</strong>从该队列中接收请求并返回一个响应消息。<strong>一个请求只会被一个消费者接收并处理</strong>，处理完成后返回<strong>响应消息</strong>给消息生产者。这种模型适用于需要<strong>请求-响应</strong>模式的场景，例如<strong>远程过程调用、微服务通信</strong>等。</li><li><strong>推拉模型</strong>（Push-Pull Model）：这种模型中，<strong>消息生产者</strong>将消息<strong>推送</strong>到一个<strong>队列</strong>中，<strong>消息消费者</strong>从该队列中<strong>拉取消息</strong>。消息生产者将消息发送到队列中，消费者<strong>按需</strong>从队列中拉取消息进行处理。这种模型适用于<strong>需要灵活控制消息消费速度</strong>的场景，例如<strong>数据采集、视频流传输</strong>等。</li></ol>',15);function b(f,P){const r=s("ExternalLinkIcon");return a(),n("div",null,[p,t("blockquote",null,[t("p",null,[l("参考："),t("a",g,[l("一文看懂｜分布式系统之CAP理论"),o(r)])])]),u,t("blockquote",null,[t("p",null,[l("参考："),t("a",h,[l("如何设计一个注册中心"),o(r)])])]),c])}const k=e(d,[["render",b],["__file","分布式.html.vue"]]);export{k as default};
