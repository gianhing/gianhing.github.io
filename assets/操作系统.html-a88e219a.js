import{_ as o,Y as t,Z as r,$ as e,a0 as l,a2 as a,a1 as n,E as s}from"./framework-5e11dbd9.js";const d={},p=n(`<h2 id="什么是进程和线程-它们有哪些区别和联系" tabindex="-1"><a class="header-anchor" href="#什么是进程和线程-它们有哪些区别和联系" aria-hidden="true">#</a> 什么是进程和线程？它们有哪些区别和联系？</h2><ol><li>进程是运行中的程序，线程是指进程内的一个执行单元，也是进程内的可调度实体。</li><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（即主线程）。</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li><li>处理机分配给线程，即真正在处理机上运行的是线程。</li><li>进程间的通信通过 IPC 机制实现，包括：管道、命名管道（FIFO）、消息队列、信号量、共享内存、套接字（Socket）。</li><li>线程间的通同步可通过 互斥（Mutex）、信号量 和 事件（Wait/Notify）实现。</li><li>线程因为有自己的独立栈空间且共享数据，所以执行的开销相对比较小，但不利于资源管理和保护；而进程执行的开销大，但可以很好的管理和保护资源。</li></ol><h2 id="死锁是什么-如何预防和避免死锁" tabindex="-1"><a class="header-anchor" href="#死锁是什么-如何预防和避免死锁" aria-hidden="true">#</a> 死锁是什么？如何预防和避免死锁？</h2><p>死锁就是多个进程在相互等待对方资源释放导致同时被阻塞，都无法继续执行。</p><p>产生死锁的四个必要条件：</p><ul><li><strong>互斥</strong>：一个资源只能被一个进程使用。</li><li><strong>不可剥夺</strong>：进程已获得的资源，在未使用完前不能被剥夺。</li><li><strong>请求与保持</strong>：进程因请求资源而阻塞时，对已有的资源保持不放。</li><li><strong>循环等待</strong>：每个进程都在等待其他进程释放资源，并且形成一个闭环。</li></ul><p>想要预防死锁，只要破坏四个必要条件中的任何一个条件：</p><ul><li><s>破坏互斥条件：将资源设为共享，最简单的方法，然而很多资源是无法同时访问的，因此大多数行不通。</s></li><li>破坏不可剥夺条件：当进程无法获取到其他资源时，释放已有资源。</li><li>破坏请求与保持条件：进程一次性申请全部资源，满足则执行，否则就等待。（资源预先分配策略）</li><li>破坏循环等待条件：对资源进行编号，进程按递增顺序请求资源，释放则相反。（资源有序分配策略）</li></ul><p>死锁的避免最典型的就是<strong>银行家算法</strong>。当进程申请系统资源时，会先尝试将资源分配给进程，通过安全性算法分析分配后系统是否处于安全状态，安全才真正分配资源，若不安全则不分配，让进程继续等待。</p><h2 id="线程间有哪些通信方式" tabindex="-1"><a class="header-anchor" href="#线程间有哪些通信方式" aria-hidden="true">#</a> 线程间有哪些通信方式？</h2><p>线程间的通信是指不同线程之间的协作和数据传递。通信方式包括以下几种方式：</p><ul><li><strong>共享内存</strong>：多个线程共享一块内存，通过读写这块内存来实现通信。Java 中利用 volatile 的可见性实现共享内存。</li><li><strong>消息传递</strong>：线程间通过发送消息来实现通信。Java 中使用 wait/notify 方法、join 方法、Condition 的 await/signal 方法实现。</li><li><strong>管道</strong>：通过管道输入/输出流实现通信。Java 中使用 PipedOutputStream 和 PipedInputStream、PipedReader 和 PipedWriter 实现。</li><li><strong>信号量</strong>：线程间通过一个信号量实现通信，可以控制线程之间的同步和互斥。Java 中利用 Semaphone 类实现。</li><li><strong>信号</strong>：线程收到信号后进行处理。Java 中利用 CountDownLatch、CyclicBarrier 实现。</li><li><strong>套接字</strong>：线程间通过一个网络连接来实现通信，可以用来在不同的计算机之间进行通信。</li></ul><h2 id="并发和并行有什么区别-同步和异步有什么区别" tabindex="-1"><a class="header-anchor" href="#并发和并行有什么区别-同步和异步有什么区别" aria-hidden="true">#</a> 并发和并行有什么区别？同步和异步有什么区别？</h2><p>并发：多个任务在<strong>同一时间段内交替进行</strong>；</p><p>并行：多个任务在<strong>同一时刻同时进行</strong>。</p><p>同步：多个任务按顺序执行，<strong>当前任务执行完才能进行下一个任务，等待时会阻塞</strong>。</p><p>异步：执行任务时<strong>不需要等待当前任务完成，可以继续执行下一个任务</strong>。</p><h2 id="线程的生命周期是什么-线程有几种状态-什么是上下文切换" tabindex="-1"><a class="header-anchor" href="#线程的生命周期是什么-线程有几种状态-什么是上下文切换" aria-hidden="true">#</a> 线程的生命周期是什么，线程有几种状态，什么是上下文切换？</h2><p>在操作系统中，线程的生命周期包含五个状态：</p><ul><li>新建状态：线程刚被创建</li><li>就绪状态：获取到除处理器外的所需资源，等待系统分配处理器资源</li><li>运行状态：正在处理器上运行</li><li>阻塞状态：线程正在等待某一事件而暂停执行，如等待 IO 操作完成</li><li>死亡状态：线程执行完毕或者因某种原因中断退出</li></ul><p>上下文切换是指操作系统内核从一个线程切换到另外线程时，需要保存当前线程的上下文状态并加载下一个线程的上下文的过程。上下文切换是多任务操作系统中的一项重要功能，它使得系统能够同时运行多个线程，从而提高系统的并发性和吞吐量。但是，上下文切换需要耗费一定的时间和系统资源，因此应该尽可能地降低上下文切换的次数。</p><h2 id="什么是零拷贝-说一说你对零拷贝的理解" tabindex="-1"><a class="header-anchor" href="#什么是零拷贝-说一说你对零拷贝的理解" aria-hidden="true">#</a> 什么是零拷贝？说一说你对零拷贝的理解？</h2><p>零拷贝是指在数据传输的过程中，尽可能的减少 CPU 和内存的拷贝操作，来提高数据传输效率和降低资源的消耗。</p><p>当程序需要从硬盘中读取数据并通过网络传输出去，在传统的数据传输的过程涉及 <code>read()</code> 和 <code>write()</code> 两个方法：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#DCDCAA;">read</span><span style="color:#D4D4D4;">(fileDesc, buf, len);</span></span>
<span class="line"><span style="color:#DCDCAA;">write</span><span style="color:#D4D4D4;">(socket, buf, len);</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://pdai.tech/images/io/java-io-copy-3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>期间会进行四次上下文切换和四次数据拷贝</strong>：</p><p>四次上下文切换：read() 和 write() 都会发起一次系统调用，每次调用都会从用户态切换到内核态，等内核完成任务后再从内核态切换回用户态</p><p>四次数据拷贝：</p><ol><li>通过 DMA 控制器将磁盘上的数据拷贝到操作系统的内核缓冲区</li><li>CPU 将内核缓冲区的数据拷贝到用户缓冲区</li><li>CPU 将用户缓冲区的数据拷贝到 socket 缓冲区</li><li>通过 DMA 控制器将 socket 缓冲区的数据拷贝到网卡</li></ol><p>在这过程中可以发现，用户态是没有对数据进行任何修改的，那为什么要先从内核缓冲区拷贝到用户缓冲区，再从用户缓冲区拷贝到 socket 缓冲区中呢？直接在内核中进行数据传输不就行了吗？这种优化思路就是零拷贝技术。</p><p>零拷贝技术的实现方式：</p><ol><li><p>mmap</p><p>可以使用 mmap() 来替代 read()，直接把内核缓冲区的数据映射到用户空间，当调用 write() 时，数据直接从内核缓冲区拷贝到 socket 缓冲区。这样减少了一次内核缓冲区到用户缓冲区的数据拷贝，但上下文切换还是四次，因为还是有两次系统调用。</p></li><li><p>sendfile</p><p>Linux 中为了解决数据拷贝问题专门设计了这一系统调用 sendfile()，可以在两个文件描述符之间进行数据拷贝，并且是在内核态中完成。因此，用 sendfile() 替换 read() 和 write()，可以减少一次数据拷贝，内核态和用户态的切换只有两次。</p></li><li><p>sendfile + SG-DMA</p><p>如果网卡支持 SG-DMA（The Scatter-Gather Direct Memory Access）技术，可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><p>使用 sendfile + SG-DMA 实现的零拷贝，只发生了两次内核态和用户态的上下文切换，两次数据拷贝，并且都是 DMA 拷贝，无需通过 CPU 来搬运数据。</p></li></ol>`,33),c={href:"https://zhuanlan.zhihu.com/p/410391372",target:"_blank",rel:"noopener noreferrer"},h={href:"https://pdai.tech/md/devops/linux/linux-zero-copy.html#mmap-write",target:"_blank",rel:"noopener noreferrer"},u=n('<h2 id="linux-中的硬链接和软连接是什么-二者有什么区别" tabindex="-1"><a class="header-anchor" href="#linux-中的硬链接和软连接是什么-二者有什么区别" aria-hidden="true">#</a> Linux 中的硬链接和软连接是什么，二者有什么区别？</h2><p>硬链接和软连接都是 Linux 中文件链接的两种形式，可以用 <code>ln</code> 命令创建，默认情况下是硬链接，加上 <code>-s</code> 选项则是软连接。它们间区别如下：</p><ul><li>硬链接： <ul><li>硬链接的 <code>inode</code> 与源文件的 <code>inode</code> 号是相同的，可以看做是多个文件名指向同一个物理文件</li><li>硬链接只能在同一个文件系统中创建，不能对目录创建</li><li>硬链接的删除只会减少链接计数，当计数为 0 时才是真正删除文件</li><li>删除源文件时，硬链接文件依旧存在，因为它们指向的是相同的索引节点</li></ul></li><li>软连接： <ul><li>软连接的 <code>inode</code> 号与源文件的 <code>inode</code> 号不同，它包含的是指向另一个文件的路径，即软连接指向源文件</li><li>软连接可以跨文件系统创建，可以对目录创建</li><li>软连接的删除只会删除连接本身，不会影响源文件</li><li>删除源文件时，软连接会变成无效连接，因为指向的文件不存在了</li></ul></li></ul><h2 id="如何在-linux-中查看系统资源使用情况-比如内存、cpu、网络端口" tabindex="-1"><a class="header-anchor" href="#如何在-linux-中查看系统资源使用情况-比如内存、cpu、网络端口" aria-hidden="true">#</a> 如何在 Linux 中查看系统资源使用情况？比如内存、CPU、网络端口</h2><ul><li><p><code>free</code>：查看系统内存的使用情况，包括系统总内存、已用内存、空闲内存等信息</p></li><li><p><code>df</code>：查看磁盘空间的使用情况，可以查看当前文件系统的总容量、已用容量、可用容量以及使用率等信息</p></li><li><p><code>top</code>：实时监控系统进程状态，包括进程 ID、 CPU 使用率、内存使用率等</p></li><li><p><code>netstat</code>：显示网络状态和端口占用信息</p></li></ul>',5);function g(f,m){const i=s("ExternalLinkIcon");return t(),r("div",null,[p,e("blockquote",null,[e("ul",null,[e("li",null,[e("a",c,[l("https://zhuanlan.zhihu.com/p/410391372"),a(i)])]),e("li",null,[e("a",h,[l("https://pdai.tech/md/devops/linux/linux-zero-copy.html#mmap-write"),a(i)])])])]),u])}const _=o(d,[["render",g],["__file","操作系统.html.vue"]]);export{_ as default};
