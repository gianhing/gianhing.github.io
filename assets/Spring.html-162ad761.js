import{_ as l,Y as e,Z as o,$ as n,a0 as i,a2 as p,a1 as a,E as t}from"./framework-5e11dbd9.js";const r={},c=a('<h2 id="spring-框架是什么-使用-spring-框架有哪些好处" tabindex="-1"><a class="header-anchor" href="#spring-框架是什么-使用-spring-框架有哪些好处" aria-hidden="true">#</a> Spring 框架是什么？使用 Spring 框架有哪些好处？</h2><p>Spring 是一款开源的 Java 应用开发框架，为了降低开发的复杂性，提高开发效率和系统的可维护性。</p><p>使用 Spring 框架的好处：</p><ol><li>控制反转（IoC）：将对象的创建交由 Spring 进行管理，让 Spring 中的 IoC 容器来管理对象的生命周期和依赖关系，降低对象的耦合度。</li><li>面向切面编程（AOP）：将那些通用模块抽取出来集中管理，减少项目中的重复代码，方便代码的重用和维护。</li><li>支持声明式事务：可以通过配置的方式实现事务的管理。</li><li>方便集成第三方框架。</li><li>方便测试：Spring 支持 Junit，能够方便的进行程序测试。</li></ol><h2 id="spring-的两大核心概念是什么" tabindex="-1"><a class="header-anchor" href="#spring-的两大核心概念是什么" aria-hidden="true">#</a> Spring 的两大核心概念是什么？</h2><p>Spring 的两大核心概念是 IoC（控制反转）和 AOP（面向切面编程）</p><p><strong>IoC（控制反转）</strong>：</p><ul><li><strong>将对象的创建交给 IoC 容器管理，由 IoC 容器来完成对象的注入</strong>。这样就不需要关注对象的创建和管理，只注重业务逻辑的实现，可以简化应用的开发。</li><li><strong>通过 XML 文件或注解的方式来配置 Bean。</strong></li><li>实现原理是<strong>工厂模式和反射机制</strong>。</li></ul><p><strong>AOP（面向切面编程）</strong>：</p><ul><li><strong>将那些与业务无关，但被业务模块所共同调用的逻辑（如日志、事务、权限）封装起来</strong>，减少重复代码，方便管理和维护。</li><li>Spring AOP 基于<strong>动态代理</strong>，如果对象实现了接口，使用 JDK 动态代理来创建代理对象；如果没有实现接口的对象，就通过 CGLIB 动态代理来生成对象的子类作为代理。</li></ul><h2 id="什么是-ioc-简单讲一下-spring-ioc-的实现机制" tabindex="-1"><a class="header-anchor" href="#什么是-ioc-简单讲一下-spring-ioc-的实现机制" aria-hidden="true">#</a> 什么是 IOC，简单讲一下 Spring IOC 的实现机制？</h2><p>IOC：控制反转，是一种设计思想。将对象的控制权交给容器管理，由容器来创建和注入依赖对象</p><p>Spring IOC 的实现机制：工厂模式 + 反射机制</p><ol><li>配置 Bean： <ul><li>xml 配置：将 bean 信息配置到 xml 文件，让 Spring 加载文件来创建 bean</li><li>Java 配置：创建配置类，添加 <code>@Configuration</code> 注解；在配置类中方法上添加 <code>@Bean</code> 注解，用来创建实例并交给 Spring 管理</li><li>注解配置：在类上添加注解（@Component、@Controller、@Service、@Repository），配置 ComponentScan 注解扫描器，Spring 就会自动扫描带以上注解的类，进行创建并管理</li></ul></li><li>创建 IOC 容器：通过 ApplicationContext 接口的相关实现类来创建 IOC 容器</li><li>加载配置文件：IOC 容器通过读取配置文件或注解的方式获取 bean 的定义和配置信息</li><li>创建 bean 实例：利用反射机制，根据配置文件中的信息实例化 bean 对象</li><li>依赖注入：根据配置文件中的依赖关系，完成 bean 之间的依赖注入。依赖注入的方式有三种： <ul><li>构造器注入：将依赖的对象通过构造方法传递给需要依赖的对象。可以保证对象在创建的时候就已经完成了依赖的注入</li><li>setter 注入：通过 setter 方法将依赖的对象注入到需要依赖的对象中。可以在对象创建完成后再进行注入操作，灵活性更高</li><li>基于注解的注入：使用注解的方式实现依赖注入。可以减少 xml 配置文件的编写量。常用的注解有 @Autowired、@Resource 和 @Inject</li></ul></li><li>初始化 bean：调用 bean 实例的初始化方法，完成 bean 实例的初始化就可以提供 bean 实例</li></ol><h2 id="spring-框架中都用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#spring-框架中都用到了哪些设计模式" aria-hidden="true">#</a> Spring 框架中都用到了哪些设计模式？</h2><ul><li>工厂模式：Spring 中通过 BeanFactory 或 ApplicationContext 创建 bean 对象就使用了工厂模式。</li><li>单例模式：Spring 中 bean 默认是单例的。</li><li>代理模式：Spring AOP 就是基于动态代理实现的。</li><li>模板方法模式：Spring 中 JdbcTemplate 就使用到了模板方法模式，封装了 JDBC 的访问操作，将一些重复性的操作放在了模板方法中，而具体的实现则交给了子类。</li><li>观察者模式：Spring 中事件驱动模型就使用了观察者模式。可以定义事件和监听器，当事件发生时，监听器就会自动调用相应的方法处理事件。</li><li>适配器模式：Spring MVC 就使用了适配器模式来实现对不同类型的请求处理器的支持。每个请求处理器都会有一个对应的适配器，该适配器会根据不同的请求调用不同的处理器进行处理，从而实现请求处理的灵活性。</li></ul>',16),d={href:"https://blog.csdn.net/caoxiaohong1005/article/details/80039656",target:"_blank",rel:"noopener noreferrer"},D=a(`<h2 id="spring、springmvc、springboot-三者之间是什么关系" tabindex="-1"><a class="header-anchor" href="#spring、springmvc、springboot-三者之间是什么关系" aria-hidden="true">#</a> Spring、SpringMVC、SpringBoot 三者之间是什么关系？</h2><ul><li>Spring 是开源的应用框架，用来构建企业级应用，Spring 提供了一系列模块来便于开发者进行应用开发，其核心是 IoC 和 AOP。</li><li>SpringMVC 是基于 Spring 的 MVC 框架，用来构建 Web 应用程序，MVC 即模型（Model）、视图（View）、控制器（Controller），实现 Web 层的职责解耦，以简化 Web 应用开发。</li><li>SpringBoot 是基于 Spring 的开源框架，用于快速构建 Spring 项目。采用“约定大于配置”的方式，并提供了许多默认配置来减少配置，简化开发，做到开箱即用。</li></ul><h2 id="有哪些注解可以注入-bean-autowired-和-resource-的区别" tabindex="-1"><a class="header-anchor" href="#有哪些注解可以注入-bean-autowired-和-resource-的区别" aria-hidden="true">#</a> 有哪些注解可以注入 Bean？@Autowired 和 @Resource 的区别？</h2><p>可以通过 <code>@Autowired</code>、<code>@Resource</code>、<code>@Inject</code> 、<code>@Value</code> 来注入 Bean，比较常用的是 <code>@Autowired</code> 和 <code>@Resource</code>。</p><ul><li>@Autowired： <ul><li>Spring 提供的注解，默认根据类型（byType）注入</li><li>如果有多个实现类，Spring 会根据名称（byName）进行匹配，但通常建议用 <code>@Qualifier</code> 来显式指定</li><li>可以作用于变量、方法、构造函数</li></ul></li><li>@Resource： <ul><li>JDK 提供的注解（JSR-250 规范），默认根据名称（byName）注入</li><li>如果有多个实现类，可以配置 <code>name</code> 属性来指定</li><li>只能作用于变量</li></ul></li><li>@Inject：JDK 提供的注解（JSR-330 规范），默认根据类型（byType）注入</li><li>@Value：注入配置文件中的属性值</li></ul><h2 id="spring-如何处理线程并发问题-threadlocal-你了解过吗" tabindex="-1"><a class="header-anchor" href="#spring-如何处理线程并发问题-threadlocal-你了解过吗" aria-hidden="true">#</a> Spring 如何处理线程并发问题，ThreadLocal 你了解过吗？</h2><p>Spring 中处理线程并发问题：</p><ol><li>加锁实现互斥：使用 <code>synchronized</code> 关键字来修饰方法或代码块，保证同一时间只能有一个线程访问；使用 <code>ReentrantLock</code> 实现多个线程对共享资源的互斥访问</li><li>使用 ThreadLocal：将变量放入 ThreadLocal 中，ThreadLocal 为每个线程提供了独立的变量副本，避免了多个线程对数据的访问冲突</li></ol><p>ThreadLocal 是线程内部的数据存储类，允许每个线程有自己独立的变量副本，避免线程安全的问题。实现原理如下：</p><ol><li>Thread 内部维护了一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的值 <code>threadLocals</code>，本质上就是一个 Map，用来存储每个线程的变量副本</li><li>每个线程在调用 ThreadLocal 中的 set() 方法时，会先获取当前线程对象的 <code>threadLocals</code> 值，然后以当前的 <code>ThreadLocal</code> 对象为 key，想要保存的值为 <code>value</code>，存入 Map 中</li><li>每个线程在调用 ThreadLocal 中的 get() 方法时，会先获取当前线程对象的 <code>threadLocals</code> 值，然后在里面找到并返回以当前 <code>ThreadLocal</code> 对象为 key 的值</li><li>线程结束时，对应的变量副本也会被销毁</li></ol><p>由于 ThreadLocal 变量的生命周期跟线程的生命周期相同，如果线程不销毁的情况下，ThreadLocal 会一直存在，需要注意内存泄漏的问题，在不需要使用的时候及时调用 <code>remove()</code> 方法清除。</p><h2 id="spring-中的-beanfactory-和-applicationcontext-有什么区别和联系" tabindex="-1"><a class="header-anchor" href="#spring-中的-beanfactory-和-applicationcontext-有什么区别和联系" aria-hidden="true">#</a> Spring 中的 BeanFactory 和 ApplicationContext 有什么区别和联系？</h2><p>BeanFactory 和 ApplicationContext 都是 Spring 中用于管理 Bean 的容器，它们间区别和联系如下：</p><ul><li><p>联系</p><p>BeanFactory 和 ApplicationContext 都是用来管理 Bean 对象，通过配置文件或注解等方式来实例化 Bean，并管理对象间的依赖关系</p></li><li><p>区别</p><ul><li>BeanFactory 是一个最基本的容器，提供基本的 IoC 功能；而 ApplicationContext 是 BeanFactory 的子接口，具备 BeanFactory 的所有能力，并提供更多的功能，如更丰富的自动装配方式、AOP 支持、国际化支持、事件机制等</li><li>ApplicationContext 在启动时就会预先实例化非懒加载的 Bean；而 BeanFactory 是在第一次调用 <code>getBean()</code> 方法时才创建 Bean 对象</li></ul></li></ul><p>ApplicationContext 相较于 BeanFactory 有更好的性能、更丰富的功能和更好的扩展性，在实际开发中，更多地使用 ApplicationContext 来管理 IoC 容器</p><h2 id="讲一讲-spring-框架中-bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#讲一讲-spring-框架中-bean-的生命周期" aria-hidden="true">#</a> 讲一讲 Spring 框架中 Bean 的生命周期？</h2><p>Spring 中 Bean 的生命周期：</p><ol><li>实例化：在 Spring 容器启动后，会读取配置文件中信息来创建 Bean 对象。Bean 的实例化可以通过构造方法或工厂方法来进行</li><li>属性注入：Spring 实例化 Bean 对象后，对 Bean 的属性进行设置。注入方式有：构造方法注入、setter 注入和字段注入</li><li>初始化：Spring 调用 Bean 的初始化方法进行初始化工作。可以通过实现 <code>InitializingBean</code> 接口，在 Bean 初始化之前或之后执行一些特定操作；也可以通过设置 <code>init-method</code> 属性，指定 Bean 初始化时需要执行的方法</li><li>使用：提供 Bean 给应用程序使用</li><li>销毁：当应用程序关闭时，Spring 容器会调用所有 Bean 的销毁方法。可以通过实现 <code>DisposableBean</code> 接口，在 Bean 被销毁前执行一些特定操作；也可以通过设置 <code>destroy-method</code> 属性，指定 Bean 销毁时需要执行的方法</li></ol><h2 id="spring-支持哪几种事务管理类型-spring-的事务实现方式和实现原理是" tabindex="-1"><a class="header-anchor" href="#spring-支持哪几种事务管理类型-spring-的事务实现方式和实现原理是" aria-hidden="true">#</a> Spring 支持哪几种事务管理类型，Spring 的事务实现方式和实现原理是？</h2><p>Spring 支持的数据管理类型如下：</p><ul><li>编程式事务管理：通过编写代码的方式实现事务管理</li><li>声明式事务管理：通过配置文件或注解的方式实现事务管理</li></ul><p>事务实现的方式是通过 AOP 实现的，Spring 容器会为需要进行事务管理的 Bean 创建一个代理对象，该代理对象会拦截所有需要进行事务管理的方法，并在执行的前后进行事务的开启、提交或回滚。</p><p>实现原理如下：</p><ol><li>当调用一个被 <code>@Transactional</code> 注解标记的方法时，Spring 会检查当前线程是否存在事务上下文，如果不存在，则会创建一个事务上下文</li><li>Spring 根据全局配置文件中的配置或 <code>@Transactional</code> 中的属性值来确定事务的隔离级别、传播特性、超时等属性</li><li>Spring 根据事务管理器创建一个数据库连接，并跟当前线程关联起来</li><li>在方法执行过程中，如果出现没被捕获到的异常，Spring 会自动回滚事务</li><li>如果方法执行成功，Spring 会根据当前事务的提交策略来决定是否提交该事务</li><li>Spring 将当前线程与数据库连接解绑，关闭连接，并清除事务上下文</li></ol><h2 id="spring-事务有哪几种事务传播行为" tabindex="-1"><a class="header-anchor" href="#spring-事务有哪几种事务传播行为" aria-hidden="true">#</a> Spring 事务有哪几种事务传播行为？</h2><p>Spring 事务传播行为用于指定当一个事务方法被另一个事务方法调用时，事务如何进行传播。Spring 支持以下 7 种事务传播行为：</p><ol><li><code>REQUIRED</code>：默认传播行为。如果当前没有任何事务的存在，就创建一个新事务；如果存在事务，则加入该事务。</li><li><code>SUPPORTS</code>：如果当前存在事务，则加入该事务；否则以非事务的方式执行。</li><li><code>MANDATORY</code>：如果当前存在事务，则加入该事务；否则抛出异常。（即当前必须存在事务）</li><li><code>REQUIRES_NEW</code>：创建一个新的事务，如果当前已经存在事务，则将它挂起。</li><li><code>NOT_SUPPORTED</code>：将事务挂起，并以非事务的方式执行。</li><li><code>NEVER</code>：不支持事务，以非事务的方式执行，如果当前存在事务，则抛出异常。</li><li><code>NESTED</code>：嵌套事务，当前事务会创建一个保存点，内部事务可独立提交或回滚；如果是外部事务回滚，会返回到保存点。</li></ol><p>可以配置 <code>@Transactional</code> 里的 <code>propagation</code> 属性来指定事务传播行为：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#D4D4D4;">@</span><span style="color:#4EC9B0;">Transactional</span><span style="color:#D4D4D4;">(propagation = </span><span style="color:#9CDCFE;">Propagation</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">REQUIRED</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="说一下-spring-事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#说一下-spring-事务的隔离级别" aria-hidden="true">#</a> 说一下 Spring 事务的隔离级别</h2><p>Spring 事务的隔离级别和标准 SQL 数据库的隔离级别是相同的，分为四个隔离级别：</p><ol><li>读未提交（READ_UNCOMMITTED）：最低隔离级别，允许一个事务可以读取到另一事务中未提交的数据。</li><li>读已提交（READ_COMMITTED）：事务只能读取到其他事务提交后的数据。可以解决脏读。</li><li>可重复读（REPEATABLE_READ）：保证事务多次读取同样的数据，得到的结果是相同的。可以解决不可重复读的问题。</li><li>可串行化（SERIALIZABLE）：最高隔离级别，事务串行执行，避免所有的并发问题，但效率较低。</li></ol><p>可以通过 <code>@Transactional</code> 中的 <code>isolation</code> 属性进行设置事务的隔离级别：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#D4D4D4;">@</span><span style="color:#4EC9B0;">Transactional</span><span style="color:#D4D4D4;">(isolation = </span><span style="color:#9CDCFE;">Isolation</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">REPEATABLE_READ</span><span style="color:#D4D4D4;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果没有显式设置 Spring 事务隔离级别，默认为 <code>DEFAULT</code>，即使用底层数据库默认的隔离级别。</p><h2 id="什么是-spring-的依赖注入-依赖注入的基本原则以及好处" tabindex="-1"><a class="header-anchor" href="#什么是-spring-的依赖注入-依赖注入的基本原则以及好处" aria-hidden="true">#</a> 什么是 Spring 的依赖注入，依赖注入的基本原则以及好处？</h2><p>Spring 依赖注入是<strong>实现 IoC 的一种设计模式</strong>，<strong>在 IoC 容器创建对象的过程中，根据配置将要依赖的对象进行注入</strong>。</p><p>依赖注入的基本原则是<strong>将组件间依赖关系的管理从程序内部转移到程序外部</strong>，即从代码中转移到配置文件上，<strong>实现松耦合的设计，减少组件间的依赖</strong>。</p><p>依赖注入的好处：</p><ul><li><strong>代码简洁</strong>：将依赖项从代码中分离出来，可以使代码更加简洁，易于理解和维护</li><li><strong>解耦</strong>：降低组件间的耦合度，使系统更加灵活和可维护</li><li><strong>可测试性</strong>：通过依赖注入可以更容易模拟依赖项，降低测试的复杂度</li><li><strong>可扩展性</strong>：通过依赖注入可以更容易添加或替换组件</li></ul><h2 id="什么是-aop-spring-aop-和-aspectj-aop-有什么区别-有哪些实现-aop-的方式" tabindex="-1"><a class="header-anchor" href="#什么是-aop-spring-aop-和-aspectj-aop-有什么区别-有哪些实现-aop-的方式" aria-hidden="true">#</a> 什么是 AOP？Spring AOP 和 AspectJ AOP 有什么区别？有哪些实现 AOP 的方式？</h2><p>AOP：面向切面编程，是一种编程思想，将一些与核心业务无关的公共逻辑（日志、事务等）抽离出来，在不改变原有业务逻辑上，以切面的方式对程序进行一个横向的扩展，提高代码的可重用性、可维护性和可扩展性。</p><p>AOP 的相关概念：</p><table><thead><tr><th>概念</th><th>含义</th></tr></thead><tbody><tr><td>目标对象（Target Object）</td><td>被切面织入的对象</td></tr><tr><td>连接点（Join Point）</td><td>可以被切面插入的地方，如方法调用、异常抛出等，所有方法都可以是连接点</td></tr><tr><td>切入点（Pointcut）</td><td>被切面增强的连接点，即哪些连接点会触发切面的通知</td></tr><tr><td>通知（Advice）</td><td>切面在连接点处执行的代码，它包括了前置通知、后置通知、环绕通知、异常通知和最终通知</td></tr><tr><td>切面（Aspect）</td><td>横切关注点的模块化，即通知 + 切入点</td></tr><tr><td>织入（Weaving）</td><td>将切面应用到目标对象的过程，可以在编译期、类加载期和运行期进行</td></tr><tr><td>引入（Introduction）</td><td>为目标对象动态的添加属性和方法</td></tr></tbody></table><p>Spring AOP 和 AspectJ AOP 是 AOP 的两种实现方式：</p><ul><li>Spring AOP 是基于<strong>动态代理</strong>实现的，通过 JDK 动态代理或 CGLIB 代理来生成代理对象，只能用于方法级别的拦截和处理，在运行时织入</li><li>AspectJ AOP 是一个更加完整的 AOP 框架，基于<strong>字节码操作</strong>，支持更多的切面表达式和切面类型，可以在编译期、类加载期进行织入，性能更加高效</li></ul><p>实现 AOP 的方式：</p><ul><li>静态代理：手动编写代理类，实现增强逻辑。需要为每个目标类编写代理类，代码量大</li><li>JDK 动态代理：利用反射机制生成代理类，只能用于实现了接口的类</li><li>CGLIB 动态代理：利用字节码生成目标类的子类（即代理类），可以代理未实现接口的类</li><li>AspectJ AOP：使用 AspectJ 在编译期或类加载期对目标类进行织入</li></ul><h2 id="spring-中的单例-bean-是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#spring-中的单例-bean-是线程安全的吗" aria-hidden="true">#</a> Spring 中的单例 bean 是线程安全的吗？</h2><blockquote><p>Spring 框架中默认的 bean 是 <code>singleton</code>（单例），可以通过 <code>@scope</code> 注解修改：</p><ul><li>singleton：一个 bean 只能有一个实例</li><li>prototype：一个 bean 可以有多个实例</li></ul></blockquote><p>因为一般在 Spring 的 bean 中注入的都是无状态的对象（没有可变的状态，如 Service 类和 DAO 类），所以在某种程度上可以算是线程安全的。如果在 bean 中定义了可被修改的成员变量，就要考虑线程安全问题，可以通过多例或加锁解决。</p><h2 id="spring-事务失效的场景有哪些" tabindex="-1"><a class="header-anchor" href="#spring-事务失效的场景有哪些" aria-hidden="true">#</a> Spring 事务失效的场景有哪些？</h2><ol><li><p>异常捕获处理</p><p>事务通知只有捕获到目标抛出的异常，才能进行后续的回滚处理。如果自己处理了异常，事务通知是无法知道的。</p><p>解决方式：在 <code>catch</code> 中手动抛出异常。</p></li><li><p>抛出检查异常</p><p>Spring 默认只能回滚未检查异常，即运行时异常。</p><p>解决方式：配置 rollbackfor 属性，即 <code>@Transactional(rollbackFor=Exception.class)</code></p></li><li><p>非 public 方法</p><p>Spring 为方法创建代理、添加事务通知的前提是该方法是 public 修饰的。</p><p>解决方式：改为 public 方法。</p></li><li><p>在同一个类中用 this 调用带有 <code>@Transactional</code> 注解的方法</p><p><code>@Transactional</code> 是通过 AOP 实现，而 AOP 是基于动态代理，当自己调用自己的过程，是不存在代理对象的调用，因此事务会失效。</p><p>解决方式：</p><ol><li>把方法拆分到不同类中</li><li>自己注入自己，用注入的实例调用</li><li>通过 <code>AopContext.currentProxy()</code> 获取代理类，利用代理类来调用方法</li></ol></li></ol><h2 id="spring-中-bean-的循环依赖问题" tabindex="-1"><a class="header-anchor" href="#spring-中-bean-的循环依赖问题" aria-hidden="true">#</a> Spring 中 bean 的循环依赖问题</h2><p>循环依赖（循环引用）：两个或两个以上的 bean 互相引用对方，最终形成闭环。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#D4D4D4;">@</span><span style="color:#4EC9B0;">Component</span></span>
<span class="line"><span style="color:#569CD6;">public</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">A</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    @</span><span style="color:#4EC9B0;">Autowired</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">private</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">B</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">b</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D4D4D4;">@</span><span style="color:#4EC9B0;">Component</span></span>
<span class="line"><span style="color:#569CD6;">public</span><span style="color:#D4D4D4;"> </span><span style="color:#569CD6;">class</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">B</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#D4D4D4;">    @</span><span style="color:#4EC9B0;">Autowired</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">private</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">A</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">a</span><span style="color:#D4D4D4;">;</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Spring 通过三级缓存解决大部分的循环依赖</p><ul><li>singletonObjects（一级缓存）：单例池，缓存已经初始化完成的 bean 对象</li><li>earlySingletonObjects（二级缓存）：缓存早期的 bean 对象（还未完全创建完）</li><li>singletonFactories（三级缓存）：缓存的是 ObjectFactory（对象工厂），用来创建某个对象的</li></ul><p>流程如下：</p><ol><li>通过构造函数实例化 A</li><li>生成 A 的对象工厂，放入三级缓存中</li><li>发现需要注入 B，B 对象不存在，实例化 B</li><li>生成 B 的对象工厂，放入三级缓存中</li><li>B 发现要注入 A，从三级缓存中取出 A 的对象工厂</li><li>通过 A 的对象工厂创建原始对象或代理对象，并放入二级缓存</li><li>将对象工厂生成的对象注入到 B，完成初始化，B 对象创建成功，放入一级缓存</li><li>将 B 注入到 A，A 创建完成，同样放入一级缓存</li></ol><p>然而，如果是通过构造方法进行相互注入的话，三级缓存是无法解决的。这时我们需要使用 <code>@Lazy</code> 注解进行懒加载，等什么时候需要对象时才进行 bean 对象的创建。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#569CD6;">public</span><span style="color:#D4D4D4;"> </span><span style="color:#DCDCAA;">A</span><span style="color:#D4D4D4;">(@</span><span style="color:#4EC9B0;">Lazy</span><span style="color:#D4D4D4;"> </span><span style="color:#4EC9B0;">B</span><span style="color:#D4D4D4;"> b) {</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#569CD6;">this</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">b</span><span style="color:#D4D4D4;"> = b;</span></span>
<span class="line"><span style="color:#D4D4D4;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="springmvc-的执行流程" tabindex="-1"><a class="header-anchor" href="#springmvc-的执行流程" aria-hidden="true">#</a> SpringMVC 的执行流程</h2><p><strong>视图阶段（JSP）</strong>：</p><ol><li>用户（浏览器）发起请求到 DispatcherServlet（前端控制器 ）</li><li>DispatcherServlet 收到请求后调用 HandlerMapping（处理器映射器），HandlerMapping 根据路径查询 Handler，并把处理器和拦截器一起返回给 DispatcherSelvet</li><li>DispatcherSelvet 调用 HandlerAdapter（处理器适配器）执行对应的 Handler（Controller）</li><li>Handler 完成之后由 HandlerAdapter 把 ModelAndView 对象返回给 DispatcherServlet</li><li>DispatcherServlet 将 ModelAndView 传给 ViewResolver（视图解析器）</li><li>ViewResolver 解析后返回具体 View</li><li>DispatcherSelvet 根据 View 进行渲染视图（将模型数据填充到视图里），并响应给用户</li></ol><p><strong>前后端开发</strong>：</p><ol><li>用户（浏览器）发起请求到 DispatcherServlet（前端控制器 ）</li><li>DispatcherServlet 收到请求后调用 HandlerMapping（处理器映射器），HandlerMapping 根据路径查询 Handler，并把处理器和拦截器一起返回给 DispatcherSelvet</li><li>DispatcherSelvet 调用 HandlerAdapter（处理器适配器）执行对应的 Handler（Controller）</li><li>Handler 里的方法上添加了 <code>@ResponseBody</code>，通过 HttpMessageConverter 来返回结果转换为 JSON 并响应</li></ol><h2 id="springboot-自动配置的原理" tabindex="-1"><a class="header-anchor" href="#springboot-自动配置的原理" aria-hidden="true">#</a> SpringBoot 自动配置的原理</h2><p>Spring Boot 项目中的引导类上有个 <code>@SpringBootApplication</code> 注解，这个注解中包含了三个注解：</p><ul><li><code>@SpringBootConfiguration</code>：与 <code>@Configuration</code> 注解作用相同，用来声明当前也是一个配置类</li><li><code>@EnableAutoConfiguration</code>：SpringBoot 实现自动化配置的核心注解</li><li><code>@ComponentScan</code>：组件扫描，默认扫描当前引导类所在包及其子包</li></ul><p><code>@EnableAutoConfiguration</code> 通过 <code>@Import</code> 注解导入对应的配置选择器。内部会读取该项目和项目引用 jar 包的 classpath 路径下 <code>META-INF/spring.factories</code> 文件中所配置类的全类名。在这些配置类中所定义的 bean 会根据 <code>@ConditionalOnClass</code> 这样的条件注解判断是否有对应的 class 文件，如果有则加载该类，并把这个配置类的所有的bean 放入 Spring 容器中使用。</p><h2 id="spring-框架中有哪些常见的注解" tabindex="-1"><a class="header-anchor" href="#spring-框架中有哪些常见的注解" aria-hidden="true">#</a> Spring 框架中有哪些常见的注解？</h2><p><strong>Spring</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component、@Controller、@Service、@Repository</td><td>使用在类上，用于声明为 Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上，根据类型进行依赖注入</td></tr><tr><td>@Qualifier</td><td>和 @Autowired 一起使用，根据名称进行依赖注入</td></tr><tr><td>@Scope</td><td>标识 Bean 的作用域</td></tr><tr><td>@Configuration</td><td>声明为配置类，提供 Bean 的定义和其他配置信息</td></tr><tr><td>@Bean</td><td>使用在方法上，将返回值加载到 Spring 容器</td></tr><tr><td>@ComponentScan</td><td>用于指定 Spring 在初始化容器时要扫描的包</td></tr><tr><td>@Import</td><td>使用@Import导入的类会被 Spring 加载到 IOC 容器中</td></tr><tr><td>@Aspect、@Before、@After、@Around、@Pointcut</td><td>用于切面编程（AOP）</td></tr></tbody></table><p><strong>SpringMVC</strong></p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@RequestMapping</td><td>用于映射请求路径，可以定义在类上和方法上</td></tr><tr><td>@RequestBody</td><td>接收 JSON 数据，并转成 Java 对象</td></tr><tr><td>@RequestParam</td><td>指定请求参数的名称</td></tr><tr><td>@PathViriable</td><td>获取请求路径上的参数</td></tr><tr><td>@ResponseBody</td><td>将 Java 对象转成 JSON 对象并响应给客户端</td></tr><tr><td>@RequestHeader</td><td>获取指定的请求头数据</td></tr><tr><td>@RestController</td><td>@Controller + @ResponseBody</td></tr></tbody></table><h2 id="mybatis-的执行流程" tabindex="-1"><a class="header-anchor" href="#mybatis-的执行流程" aria-hidden="true">#</a> MyBatis 的执行流程</h2><ol><li>读取 MyBatis 配置文件 <code>mybatis-config.xml</code>（指定数据库源和加载映射文件）</li><li>构建会话工厂 SqlSessionFactory（全局唯一）</li><li>由会话工厂创建 SqlSession 对象（包含执行 SQL 语句的所有方法，每次操作都会产生一次会话，有多个）</li><li>由 Executor 执行器真正执行数据库操作接口，同时负责查询缓存的维护</li><li>Executor 接口的执行方法中有一个 MappedStatement 类型的参数，封装了映射信息（将 Java 支持的数据类型和数据库支持的数据类型进行相互转换）</li></ol><h2 id="mybatis-的延迟加载和底层实现" tabindex="-1"><a class="header-anchor" href="#mybatis-的延迟加载和底层实现" aria-hidden="true">#</a> MyBatis 的延迟加载和底层实现</h2><p>MyBatis 的延迟加载：使用 MyBatis 进行查询时，不会直接将关联的数据一起加载出来，而是等到需要时才进行查询加载。</p><p>MyBatis 支持<strong>一对一关联对象</strong>和<strong>一对多关联集合对象</strong>的延迟加载。但 MyBatis 默认关闭延迟加载功能，可以通过以下几种方式开启：</p><ol><li>在 mapper 文件中指定 <code>fetchType=&quot;lazy&quot;</code></li></ol><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">resultMap</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">id</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;userResultMap&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">type</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;user&quot;</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">id</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">property</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;id&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">column</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;id&quot;</span><span style="color:#808080;">/&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">result</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">property</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;name&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">column</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;name&quot;</span><span style="color:#808080;">/&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">collection</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">property</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;orderList&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">ofType</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;order&quot;</span></span>
<span class="line"><span style="color:#D4D4D4;">              </span><span style="color:#9CDCFE;">select</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;com.test.mapper.OrderMapper.findByUid&quot;</span></span>
<span class="line"><span style="color:#D4D4D4;">              </span><span style="color:#9CDCFE;">column</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;id&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">fetchType</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;lazy&quot;</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">collection</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">resultMap</span><span style="color:#808080;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>设置全局属性</li></ol><p>在 <code>mybatis-config.xml</code> 配置文件中设置：</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">configuration</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">settings</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">&lt;!-- 开启延迟加载 --&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">setting</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;lazyLoadingEnabled&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">value</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;true&quot;</span><span style="color:#808080;">/&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">settings</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">configuration</span><span style="color:#808080;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>延迟加载的底层原理</strong>：</p><p>基于动态代理的方式创建目标对象的代理对象，拦截对象的 getter 方法。当调用 getter 方法时，会进入代理对象的 invoke 方法，判断目标方法的返回结果是否为空，为空则执行 SQL 查询，并通过 set 方法赋值。就可以通过 get 方法获取到值。</p><h2 id="mybatis-一级、二级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis-一级、二级缓存" aria-hidden="true">#</a> MyBatis 一级、二级缓存</h2><p>MyBatis 的一级、二级缓存都是本地缓存，基于 PerpetualCache，本质是一个 HashMap。</p><p><strong>一级缓存</strong>：作用域为 SqlSession，当 SqlSession 进行 flush 或 close 之后，该 Session 的所有 Cache 都会被清空。MyBatis 默认开启一级缓存。</p><p><strong>二级缓存</strong>：作用域为 namespace 和 mapper。二级缓存是默认关闭的，需要手动开启：</p><ul><li>第一步：设置全局配置文件 <code>mybatis-config.xml</code></li></ul><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="shiki dark-plus" style="background-color:#1E1E1E;" tabindex="0"><code><span class="line"><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">configuration</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">settings</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#6A9955;">&lt;!-- 开启二级缓存 --&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">    </span><span style="color:#808080;">&lt;</span><span style="color:#569CD6;">setting</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">name</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;cacheEnabled&quot;</span><span style="color:#D4D4D4;"> </span><span style="color:#9CDCFE;">value</span><span style="color:#D4D4D4;">=</span><span style="color:#CE9178;">&quot;true&quot;</span><span style="color:#808080;">/&gt;</span></span>
<span class="line"><span style="color:#D4D4D4;">  </span><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">settings</span><span style="color:#808080;">&gt;</span></span>
<span class="line"><span style="color:#808080;">&lt;/</span><span style="color:#569CD6;">configuration</span><span style="color:#808080;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>第二步：在映射文件中使用 <code>&lt;cache/&gt;</code> 标签让当前 mapper 生效二级缓存</li></ul><p><strong>注意</strong>：</p><ol><li>缓存更新机制：当某一个作用域（一级缓存 SqlSession / 二级缓存 namespace）的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear</li><li>二级缓存中需要缓存的数据要实现 Serializable 接口</li><li>只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li></ol>`,97);function g(y,u){const s=t("ExternalLinkIcon");return e(),o("div",null,[c,n("blockquote",null,[n("p",null,[n("a",d,[i("Spring中涉及的设计模式总结"),p(s)])])]),D])}const b=l(r,[["render",g],["__file","Spring.html.vue"]]);export{b as default};
